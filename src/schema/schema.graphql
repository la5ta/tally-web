schema {
  query: query_root
  mutation: mutation_root
  subscription: subscription_root
}

scalar bit

# expression to compare columns of type bit. All fields are combined with logical 'AND'.
input bit_comparison_exp {
  _eq: bit
  _gt: bit
  _gte: bit
  _in: [bit!]
  _is_null: Boolean
  _lt: bit
  _lte: bit
  _neq: bit
  _nin: [bit!]
}

# expression to compare columns of type Boolean. All fields are combined with logical 'AND'.
input Boolean_comparison_exp {
  _eq: Boolean
  _gt: Boolean
  _gte: Boolean
  _in: [Boolean!]
  _is_null: Boolean
  _lt: Boolean
  _lte: Boolean
  _neq: Boolean
  _nin: [Boolean!]
}

# columns and relationships of "cities"
type cities {
  _id: uuid!

  # An object relationship
  country: countries!
  country_id: uuid!
  created_at: timestamp

  # An array relationship
  customers_addresses(
    # distinct select on columns
    distinct_on: [customers_address_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customers_address_order_by!]

    # filter the rows returned
    where: customers_address_bool_exp
  ): [customers_address!]!

  # An aggregated array relationship
  customers_addresses_aggregate(
    # distinct select on columns
    distinct_on: [customers_address_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customers_address_order_by!]

    # filter the rows returned
    where: customers_address_bool_exp
  ): customers_address_aggregate!
  full_name: String!
  short_name: String

  # An array relationship
  stores(
    # distinct select on columns
    distinct_on: [stores_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [stores_order_by!]

    # filter the rows returned
    where: stores_bool_exp
  ): [stores!]!

  # An aggregated array relationship
  stores_aggregate(
    # distinct select on columns
    distinct_on: [stores_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [stores_order_by!]

    # filter the rows returned
    where: stores_bool_exp
  ): stores_aggregate!
}

# aggregated selection of "cities"
type cities_aggregate {
  aggregate: cities_aggregate_fields
  nodes: [cities!]!
}

# aggregate fields of "cities"
type cities_aggregate_fields {
  count(columns: [cities_select_column!], distinct: Boolean): Int
  max: cities_max_fields
  min: cities_min_fields
}

# order by aggregate values of table "cities"
input cities_aggregate_order_by {
  count: order_by
  max: cities_max_order_by
  min: cities_min_order_by
}

# input type for inserting array relation for remote table "cities"
input cities_arr_rel_insert_input {
  data: [cities_insert_input!]!
  on_conflict: cities_on_conflict
}

# Boolean expression to filter rows from the table "cities". All fields are combined with a logical 'AND'.
input cities_bool_exp {
  _and: [cities_bool_exp]
  _id: uuid_comparison_exp
  _not: cities_bool_exp
  _or: [cities_bool_exp]
  country: countries_bool_exp
  country_id: uuid_comparison_exp
  created_at: timestamp_comparison_exp
  customers_addresses: customers_address_bool_exp
  full_name: String_comparison_exp
  short_name: String_comparison_exp
  stores: stores_bool_exp
}

# unique or primary key constraints on table "cities"
enum cities_constraint {
  # unique or primary key constraint
  cities_pkey
}

# input type for inserting data into table "cities"
input cities_insert_input {
  _id: uuid
  country: countries_obj_rel_insert_input
  country_id: uuid
  created_at: timestamp
  customers_addresses: customers_address_arr_rel_insert_input
  full_name: String
  short_name: String
  stores: stores_arr_rel_insert_input
}

# aggregate max on columns
type cities_max_fields {
  _id: uuid
  country_id: uuid
  created_at: timestamp
  full_name: String
  short_name: String
}

# order by max() on columns of table "cities"
input cities_max_order_by {
  _id: order_by
  country_id: order_by
  created_at: order_by
  full_name: order_by
  short_name: order_by
}

# aggregate min on columns
type cities_min_fields {
  _id: uuid
  country_id: uuid
  created_at: timestamp
  full_name: String
  short_name: String
}

# order by min() on columns of table "cities"
input cities_min_order_by {
  _id: order_by
  country_id: order_by
  created_at: order_by
  full_name: order_by
  short_name: order_by
}

# response of any mutation on the table "cities"
type cities_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [cities!]!
}

# input type for inserting object relation for remote table "cities"
input cities_obj_rel_insert_input {
  data: cities_insert_input!
  on_conflict: cities_on_conflict
}

# on conflict condition type for table "cities"
input cities_on_conflict {
  constraint: cities_constraint!
  update_columns: [cities_update_column!]!
  where: cities_bool_exp
}

# ordering options when selecting data from "cities"
input cities_order_by {
  _id: order_by
  country: countries_order_by
  country_id: order_by
  created_at: order_by
  customers_addresses_aggregate: customers_address_aggregate_order_by
  full_name: order_by
  short_name: order_by
  stores_aggregate: stores_aggregate_order_by
}

# primary key columns input for table: "cities"
input cities_pk_columns_input {
  _id: uuid!
}

# select columns of table "cities"
enum cities_select_column {
  # column name
  _id

  # column name
  country_id

  # column name
  created_at

  # column name
  full_name

  # column name
  short_name
}

# input type for updating data in table "cities"
input cities_set_input {
  _id: uuid
  country_id: uuid
  created_at: timestamp
  full_name: String
  short_name: String
}

# update columns of table "cities"
enum cities_update_column {
  # column name
  _id

  # column name
  country_id

  # column name
  created_at

  # column name
  full_name

  # column name
  short_name
}

# columns and relationships of "countries"
type countries {
  _id: uuid!

  # An array relationship
  cities(
    # distinct select on columns
    distinct_on: [cities_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cities_order_by!]

    # filter the rows returned
    where: cities_bool_exp
  ): [cities!]!

  # An aggregated array relationship
  cities_aggregate(
    # distinct select on columns
    distinct_on: [cities_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cities_order_by!]

    # filter the rows returned
    where: cities_bool_exp
  ): cities_aggregate!

  # An array relationship
  countries_currencies(
    # distinct select on columns
    distinct_on: [countries_currency_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [countries_currency_order_by!]

    # filter the rows returned
    where: countries_currency_bool_exp
  ): [countries_currency!]!

  # An aggregated array relationship
  countries_currencies_aggregate(
    # distinct select on columns
    distinct_on: [countries_currency_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [countries_currency_order_by!]

    # filter the rows returned
    where: countries_currency_bool_exp
  ): countries_currency_aggregate!
  created_at: timestamp
  currency: String

  # An array relationship
  customers_addresses(
    # distinct select on columns
    distinct_on: [customers_address_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customers_address_order_by!]

    # filter the rows returned
    where: customers_address_bool_exp
  ): [customers_address!]!

  # An aggregated array relationship
  customers_addresses_aggregate(
    # distinct select on columns
    distinct_on: [customers_address_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customers_address_order_by!]

    # filter the rows returned
    where: customers_address_bool_exp
  ): customers_address_aggregate!
  emoji: String
  emoji_u: String
  iso_2: String
  iso_3: String
  name: String!
  phone_code: Int
}

# aggregated selection of "countries"
type countries_aggregate {
  aggregate: countries_aggregate_fields
  nodes: [countries!]!
}

# aggregate fields of "countries"
type countries_aggregate_fields {
  avg: countries_avg_fields
  count(columns: [countries_select_column!], distinct: Boolean): Int
  max: countries_max_fields
  min: countries_min_fields
  stddev: countries_stddev_fields
  stddev_pop: countries_stddev_pop_fields
  stddev_samp: countries_stddev_samp_fields
  sum: countries_sum_fields
  var_pop: countries_var_pop_fields
  var_samp: countries_var_samp_fields
  variance: countries_variance_fields
}

# order by aggregate values of table "countries"
input countries_aggregate_order_by {
  avg: countries_avg_order_by
  count: order_by
  max: countries_max_order_by
  min: countries_min_order_by
  stddev: countries_stddev_order_by
  stddev_pop: countries_stddev_pop_order_by
  stddev_samp: countries_stddev_samp_order_by
  sum: countries_sum_order_by
  var_pop: countries_var_pop_order_by
  var_samp: countries_var_samp_order_by
  variance: countries_variance_order_by
}

# input type for inserting array relation for remote table "countries"
input countries_arr_rel_insert_input {
  data: [countries_insert_input!]!
  on_conflict: countries_on_conflict
}

# aggregate avg on columns
type countries_avg_fields {
  phone_code: Float
}

# order by avg() on columns of table "countries"
input countries_avg_order_by {
  phone_code: order_by
}

# Boolean expression to filter rows from the table "countries". All fields are combined with a logical 'AND'.
input countries_bool_exp {
  _and: [countries_bool_exp]
  _id: uuid_comparison_exp
  _not: countries_bool_exp
  _or: [countries_bool_exp]
  cities: cities_bool_exp
  countries_currencies: countries_currency_bool_exp
  created_at: timestamp_comparison_exp
  currency: String_comparison_exp
  customers_addresses: customers_address_bool_exp
  emoji: String_comparison_exp
  emoji_u: String_comparison_exp
  iso_2: String_comparison_exp
  iso_3: String_comparison_exp
  name: String_comparison_exp
  phone_code: Int_comparison_exp
}

# unique or primary key constraints on table "countries"
enum countries_constraint {
  # unique or primary key constraint
  countries_full_name_key

  # unique or primary key constraint
  countries_iso_2_key

  # unique or primary key constraint
  countries_pkey

  # unique or primary key constraint
  countries_short_name_key
}

# columns and relationships of "countries_currency"
type countries_currency {
  _id: uuid!
  abbreviation: String

  # An object relationship
  country: countries!
  country_id: uuid!
  created_at: timestamp
  description: String
}

# aggregated selection of "countries_currency"
type countries_currency_aggregate {
  aggregate: countries_currency_aggregate_fields
  nodes: [countries_currency!]!
}

# aggregate fields of "countries_currency"
type countries_currency_aggregate_fields {
  count(columns: [countries_currency_select_column!], distinct: Boolean): Int
  max: countries_currency_max_fields
  min: countries_currency_min_fields
}

# order by aggregate values of table "countries_currency"
input countries_currency_aggregate_order_by {
  count: order_by
  max: countries_currency_max_order_by
  min: countries_currency_min_order_by
}

# input type for inserting array relation for remote table "countries_currency"
input countries_currency_arr_rel_insert_input {
  data: [countries_currency_insert_input!]!
  on_conflict: countries_currency_on_conflict
}

# Boolean expression to filter rows from the table "countries_currency". All fields are combined with a logical 'AND'.
input countries_currency_bool_exp {
  _and: [countries_currency_bool_exp]
  _id: uuid_comparison_exp
  _not: countries_currency_bool_exp
  _or: [countries_currency_bool_exp]
  abbreviation: String_comparison_exp
  country: countries_bool_exp
  country_id: uuid_comparison_exp
  created_at: timestamp_comparison_exp
  description: String_comparison_exp
}

# unique or primary key constraints on table "countries_currency"
enum countries_currency_constraint {
  # unique or primary key constraint
  countries_currency_abbreviation_key

  # unique or primary key constraint
  countries_currency_pkey
}

# input type for inserting data into table "countries_currency"
input countries_currency_insert_input {
  _id: uuid
  abbreviation: String
  country: countries_obj_rel_insert_input
  country_id: uuid
  created_at: timestamp
  description: String
}

# aggregate max on columns
type countries_currency_max_fields {
  _id: uuid
  abbreviation: String
  country_id: uuid
  created_at: timestamp
  description: String
}

# order by max() on columns of table "countries_currency"
input countries_currency_max_order_by {
  _id: order_by
  abbreviation: order_by
  country_id: order_by
  created_at: order_by
  description: order_by
}

# aggregate min on columns
type countries_currency_min_fields {
  _id: uuid
  abbreviation: String
  country_id: uuid
  created_at: timestamp
  description: String
}

# order by min() on columns of table "countries_currency"
input countries_currency_min_order_by {
  _id: order_by
  abbreviation: order_by
  country_id: order_by
  created_at: order_by
  description: order_by
}

# response of any mutation on the table "countries_currency"
type countries_currency_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [countries_currency!]!
}

# input type for inserting object relation for remote table "countries_currency"
input countries_currency_obj_rel_insert_input {
  data: countries_currency_insert_input!
  on_conflict: countries_currency_on_conflict
}

# on conflict condition type for table "countries_currency"
input countries_currency_on_conflict {
  constraint: countries_currency_constraint!
  update_columns: [countries_currency_update_column!]!
  where: countries_currency_bool_exp
}

# ordering options when selecting data from "countries_currency"
input countries_currency_order_by {
  _id: order_by
  abbreviation: order_by
  country: countries_order_by
  country_id: order_by
  created_at: order_by
  description: order_by
}

# primary key columns input for table: "countries_currency"
input countries_currency_pk_columns_input {
  _id: uuid!
}

# select columns of table "countries_currency"
enum countries_currency_select_column {
  # column name
  _id

  # column name
  abbreviation

  # column name
  country_id

  # column name
  created_at

  # column name
  description
}

# input type for updating data in table "countries_currency"
input countries_currency_set_input {
  _id: uuid
  abbreviation: String
  country_id: uuid
  created_at: timestamp
  description: String
}

# update columns of table "countries_currency"
enum countries_currency_update_column {
  # column name
  _id

  # column name
  abbreviation

  # column name
  country_id

  # column name
  created_at

  # column name
  description
}

# input type for incrementing integer column in table "countries"
input countries_inc_input {
  phone_code: Int
}

# input type for inserting data into table "countries"
input countries_insert_input {
  _id: uuid
  cities: cities_arr_rel_insert_input
  countries_currencies: countries_currency_arr_rel_insert_input
  created_at: timestamp
  currency: String
  customers_addresses: customers_address_arr_rel_insert_input
  emoji: String
  emoji_u: String
  iso_2: String
  iso_3: String
  name: String
  phone_code: Int
}

# aggregate max on columns
type countries_max_fields {
  _id: uuid
  created_at: timestamp
  currency: String
  emoji: String
  emoji_u: String
  iso_2: String
  iso_3: String
  name: String
  phone_code: Int
}

# order by max() on columns of table "countries"
input countries_max_order_by {
  _id: order_by
  created_at: order_by
  currency: order_by
  emoji: order_by
  emoji_u: order_by
  iso_2: order_by
  iso_3: order_by
  name: order_by
  phone_code: order_by
}

# aggregate min on columns
type countries_min_fields {
  _id: uuid
  created_at: timestamp
  currency: String
  emoji: String
  emoji_u: String
  iso_2: String
  iso_3: String
  name: String
  phone_code: Int
}

# order by min() on columns of table "countries"
input countries_min_order_by {
  _id: order_by
  created_at: order_by
  currency: order_by
  emoji: order_by
  emoji_u: order_by
  iso_2: order_by
  iso_3: order_by
  name: order_by
  phone_code: order_by
}

# response of any mutation on the table "countries"
type countries_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [countries!]!
}

# input type for inserting object relation for remote table "countries"
input countries_obj_rel_insert_input {
  data: countries_insert_input!
  on_conflict: countries_on_conflict
}

# on conflict condition type for table "countries"
input countries_on_conflict {
  constraint: countries_constraint!
  update_columns: [countries_update_column!]!
  where: countries_bool_exp
}

# ordering options when selecting data from "countries"
input countries_order_by {
  _id: order_by
  cities_aggregate: cities_aggregate_order_by
  countries_currencies_aggregate: countries_currency_aggregate_order_by
  created_at: order_by
  currency: order_by
  customers_addresses_aggregate: customers_address_aggregate_order_by
  emoji: order_by
  emoji_u: order_by
  iso_2: order_by
  iso_3: order_by
  name: order_by
  phone_code: order_by
}

# primary key columns input for table: "countries"
input countries_pk_columns_input {
  _id: uuid!
}

# select columns of table "countries"
enum countries_select_column {
  # column name
  _id

  # column name
  created_at

  # column name
  currency

  # column name
  emoji

  # column name
  emoji_u

  # column name
  iso_2

  # column name
  iso_3

  # column name
  name

  # column name
  phone_code
}

# input type for updating data in table "countries"
input countries_set_input {
  _id: uuid
  created_at: timestamp
  currency: String
  emoji: String
  emoji_u: String
  iso_2: String
  iso_3: String
  name: String
  phone_code: Int
}

# aggregate stddev on columns
type countries_stddev_fields {
  phone_code: Float
}

# order by stddev() on columns of table "countries"
input countries_stddev_order_by {
  phone_code: order_by
}

# aggregate stddev_pop on columns
type countries_stddev_pop_fields {
  phone_code: Float
}

# order by stddev_pop() on columns of table "countries"
input countries_stddev_pop_order_by {
  phone_code: order_by
}

# aggregate stddev_samp on columns
type countries_stddev_samp_fields {
  phone_code: Float
}

# order by stddev_samp() on columns of table "countries"
input countries_stddev_samp_order_by {
  phone_code: order_by
}

# aggregate sum on columns
type countries_sum_fields {
  phone_code: Int
}

# order by sum() on columns of table "countries"
input countries_sum_order_by {
  phone_code: order_by
}

# columns and relationships of "countries_taxes"
type countries_taxes {
  _id: uuid!
  abbreviation: String
  country_id: uuid!
  created_at: timestamp
  description: String

  # An array relationship
  products(
    # distinct select on columns
    distinct_on: [products_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_order_by!]

    # filter the rows returned
    where: products_bool_exp
  ): [products!]!

  # An aggregated array relationship
  products_aggregate(
    # distinct select on columns
    distinct_on: [products_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_order_by!]

    # filter the rows returned
    where: products_bool_exp
  ): products_aggregate!
  value: numeric
}

# aggregated selection of "countries_taxes"
type countries_taxes_aggregate {
  aggregate: countries_taxes_aggregate_fields
  nodes: [countries_taxes!]!
}

# aggregate fields of "countries_taxes"
type countries_taxes_aggregate_fields {
  avg: countries_taxes_avg_fields
  count(columns: [countries_taxes_select_column!], distinct: Boolean): Int
  max: countries_taxes_max_fields
  min: countries_taxes_min_fields
  stddev: countries_taxes_stddev_fields
  stddev_pop: countries_taxes_stddev_pop_fields
  stddev_samp: countries_taxes_stddev_samp_fields
  sum: countries_taxes_sum_fields
  var_pop: countries_taxes_var_pop_fields
  var_samp: countries_taxes_var_samp_fields
  variance: countries_taxes_variance_fields
}

# order by aggregate values of table "countries_taxes"
input countries_taxes_aggregate_order_by {
  avg: countries_taxes_avg_order_by
  count: order_by
  max: countries_taxes_max_order_by
  min: countries_taxes_min_order_by
  stddev: countries_taxes_stddev_order_by
  stddev_pop: countries_taxes_stddev_pop_order_by
  stddev_samp: countries_taxes_stddev_samp_order_by
  sum: countries_taxes_sum_order_by
  var_pop: countries_taxes_var_pop_order_by
  var_samp: countries_taxes_var_samp_order_by
  variance: countries_taxes_variance_order_by
}

# input type for inserting array relation for remote table "countries_taxes"
input countries_taxes_arr_rel_insert_input {
  data: [countries_taxes_insert_input!]!
  on_conflict: countries_taxes_on_conflict
}

# aggregate avg on columns
type countries_taxes_avg_fields {
  value: Float
}

# order by avg() on columns of table "countries_taxes"
input countries_taxes_avg_order_by {
  value: order_by
}

# Boolean expression to filter rows from the table "countries_taxes". All fields are combined with a logical 'AND'.
input countries_taxes_bool_exp {
  _and: [countries_taxes_bool_exp]
  _id: uuid_comparison_exp
  _not: countries_taxes_bool_exp
  _or: [countries_taxes_bool_exp]
  abbreviation: String_comparison_exp
  country_id: uuid_comparison_exp
  created_at: timestamp_comparison_exp
  description: String_comparison_exp
  products: products_bool_exp
  value: numeric_comparison_exp
}

# unique or primary key constraints on table "countries_taxes"
enum countries_taxes_constraint {
  # unique or primary key constraint
  countries_taxes_pkey
}

# input type for incrementing integer column in table "countries_taxes"
input countries_taxes_inc_input {
  value: numeric
}

# input type for inserting data into table "countries_taxes"
input countries_taxes_insert_input {
  _id: uuid
  abbreviation: String
  country_id: uuid
  created_at: timestamp
  description: String
  products: products_arr_rel_insert_input
  value: numeric
}

# aggregate max on columns
type countries_taxes_max_fields {
  _id: uuid
  abbreviation: String
  country_id: uuid
  created_at: timestamp
  description: String
  value: numeric
}

# order by max() on columns of table "countries_taxes"
input countries_taxes_max_order_by {
  _id: order_by
  abbreviation: order_by
  country_id: order_by
  created_at: order_by
  description: order_by
  value: order_by
}

# aggregate min on columns
type countries_taxes_min_fields {
  _id: uuid
  abbreviation: String
  country_id: uuid
  created_at: timestamp
  description: String
  value: numeric
}

# order by min() on columns of table "countries_taxes"
input countries_taxes_min_order_by {
  _id: order_by
  abbreviation: order_by
  country_id: order_by
  created_at: order_by
  description: order_by
  value: order_by
}

# response of any mutation on the table "countries_taxes"
type countries_taxes_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [countries_taxes!]!
}

# input type for inserting object relation for remote table "countries_taxes"
input countries_taxes_obj_rel_insert_input {
  data: countries_taxes_insert_input!
  on_conflict: countries_taxes_on_conflict
}

# on conflict condition type for table "countries_taxes"
input countries_taxes_on_conflict {
  constraint: countries_taxes_constraint!
  update_columns: [countries_taxes_update_column!]!
  where: countries_taxes_bool_exp
}

# ordering options when selecting data from "countries_taxes"
input countries_taxes_order_by {
  _id: order_by
  abbreviation: order_by
  country_id: order_by
  created_at: order_by
  description: order_by
  products_aggregate: products_aggregate_order_by
  value: order_by
}

# primary key columns input for table: "countries_taxes"
input countries_taxes_pk_columns_input {
  _id: uuid!
}

# select columns of table "countries_taxes"
enum countries_taxes_select_column {
  # column name
  _id

  # column name
  abbreviation

  # column name
  country_id

  # column name
  created_at

  # column name
  description

  # column name
  value
}

# input type for updating data in table "countries_taxes"
input countries_taxes_set_input {
  _id: uuid
  abbreviation: String
  country_id: uuid
  created_at: timestamp
  description: String
  value: numeric
}

# aggregate stddev on columns
type countries_taxes_stddev_fields {
  value: Float
}

# order by stddev() on columns of table "countries_taxes"
input countries_taxes_stddev_order_by {
  value: order_by
}

# aggregate stddev_pop on columns
type countries_taxes_stddev_pop_fields {
  value: Float
}

# order by stddev_pop() on columns of table "countries_taxes"
input countries_taxes_stddev_pop_order_by {
  value: order_by
}

# aggregate stddev_samp on columns
type countries_taxes_stddev_samp_fields {
  value: Float
}

# order by stddev_samp() on columns of table "countries_taxes"
input countries_taxes_stddev_samp_order_by {
  value: order_by
}

# aggregate sum on columns
type countries_taxes_sum_fields {
  value: numeric
}

# order by sum() on columns of table "countries_taxes"
input countries_taxes_sum_order_by {
  value: order_by
}

# update columns of table "countries_taxes"
enum countries_taxes_update_column {
  # column name
  _id

  # column name
  abbreviation

  # column name
  country_id

  # column name
  created_at

  # column name
  description

  # column name
  value
}

# aggregate var_pop on columns
type countries_taxes_var_pop_fields {
  value: Float
}

# order by var_pop() on columns of table "countries_taxes"
input countries_taxes_var_pop_order_by {
  value: order_by
}

# aggregate var_samp on columns
type countries_taxes_var_samp_fields {
  value: Float
}

# order by var_samp() on columns of table "countries_taxes"
input countries_taxes_var_samp_order_by {
  value: order_by
}

# aggregate variance on columns
type countries_taxes_variance_fields {
  value: Float
}

# order by variance() on columns of table "countries_taxes"
input countries_taxes_variance_order_by {
  value: order_by
}

# update columns of table "countries"
enum countries_update_column {
  # column name
  _id

  # column name
  created_at

  # column name
  currency

  # column name
  emoji

  # column name
  emoji_u

  # column name
  iso_2

  # column name
  iso_3

  # column name
  name

  # column name
  phone_code
}

# aggregate var_pop on columns
type countries_var_pop_fields {
  phone_code: Float
}

# order by var_pop() on columns of table "countries"
input countries_var_pop_order_by {
  phone_code: order_by
}

# aggregate var_samp on columns
type countries_var_samp_fields {
  phone_code: Float
}

# order by var_samp() on columns of table "countries"
input countries_var_samp_order_by {
  phone_code: order_by
}

# aggregate variance on columns
type countries_variance_fields {
  phone_code: Float
}

# order by variance() on columns of table "countries"
input countries_variance_order_by {
  phone_code: order_by
}

# columns and relationships of "customers"
type customers {
  _id: uuid!
  accept_emarketing: bit
  created_at: timestamp

  # An array relationship
  customers_addresses(
    # distinct select on columns
    distinct_on: [customers_address_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customers_address_order_by!]

    # filter the rows returned
    where: customers_address_bool_exp
  ): [customers_address!]!

  # An aggregated array relationship
  customers_addresses_aggregate(
    # distinct select on columns
    distinct_on: [customers_address_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customers_address_order_by!]

    # filter the rows returned
    where: customers_address_bool_exp
  ): customers_address_aggregate!

  # An array relationship
  customers_tags(
    # distinct select on columns
    distinct_on: [customers_tags_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customers_tags_order_by!]

    # filter the rows returned
    where: customers_tags_bool_exp
  ): [customers_tags!]!

  # An aggregated array relationship
  customers_tags_aggregate(
    # distinct select on columns
    distinct_on: [customers_tags_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customers_tags_order_by!]

    # filter the rows returned
    where: customers_tags_bool_exp
  ): customers_tags_aggregate!

  # An array relationship
  draft_orders(
    # distinct select on columns
    distinct_on: [draft_orders_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [draft_orders_order_by!]

    # filter the rows returned
    where: draft_orders_bool_exp
  ): [draft_orders!]!

  # An aggregated array relationship
  draft_orders_aggregate(
    # distinct select on columns
    distinct_on: [draft_orders_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [draft_orders_order_by!]

    # filter the rows returned
    where: draft_orders_bool_exp
  ): draft_orders_aggregate!
  email: String
  first_name: String
  last_name: String

  # An array relationship
  orders(
    # distinct select on columns
    distinct_on: [orders_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [orders_order_by!]

    # filter the rows returned
    where: orders_bool_exp
  ): [orders!]!

  # An aggregated array relationship
  orders_aggregate(
    # distinct select on columns
    distinct_on: [orders_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [orders_order_by!]

    # filter the rows returned
    where: orders_bool_exp
  ): orders_aggregate!
  phone_number: String
}

# columns and relationships of "customers_address"
type customers_address {
  _id: uuid!
  address: String

  # An object relationship
  city: cities!
  city_id: uuid!

  # An object relationship
  country: countries!
  country_id: uuid!
  created_at: timestamp

  # An object relationship
  customer: customers!
  customer_id: uuid!
  latitude: numeric
  longitude: numeric
}

# aggregated selection of "customers_address"
type customers_address_aggregate {
  aggregate: customers_address_aggregate_fields
  nodes: [customers_address!]!
}

# aggregate fields of "customers_address"
type customers_address_aggregate_fields {
  avg: customers_address_avg_fields
  count(columns: [customers_address_select_column!], distinct: Boolean): Int
  max: customers_address_max_fields
  min: customers_address_min_fields
  stddev: customers_address_stddev_fields
  stddev_pop: customers_address_stddev_pop_fields
  stddev_samp: customers_address_stddev_samp_fields
  sum: customers_address_sum_fields
  var_pop: customers_address_var_pop_fields
  var_samp: customers_address_var_samp_fields
  variance: customers_address_variance_fields
}

# order by aggregate values of table "customers_address"
input customers_address_aggregate_order_by {
  avg: customers_address_avg_order_by
  count: order_by
  max: customers_address_max_order_by
  min: customers_address_min_order_by
  stddev: customers_address_stddev_order_by
  stddev_pop: customers_address_stddev_pop_order_by
  stddev_samp: customers_address_stddev_samp_order_by
  sum: customers_address_sum_order_by
  var_pop: customers_address_var_pop_order_by
  var_samp: customers_address_var_samp_order_by
  variance: customers_address_variance_order_by
}

# input type for inserting array relation for remote table "customers_address"
input customers_address_arr_rel_insert_input {
  data: [customers_address_insert_input!]!
  on_conflict: customers_address_on_conflict
}

# aggregate avg on columns
type customers_address_avg_fields {
  latitude: Float
  longitude: Float
}

# order by avg() on columns of table "customers_address"
input customers_address_avg_order_by {
  latitude: order_by
  longitude: order_by
}

# Boolean expression to filter rows from the table "customers_address". All fields are combined with a logical 'AND'.
input customers_address_bool_exp {
  _and: [customers_address_bool_exp]
  _id: uuid_comparison_exp
  _not: customers_address_bool_exp
  _or: [customers_address_bool_exp]
  address: String_comparison_exp
  city: cities_bool_exp
  city_id: uuid_comparison_exp
  country: countries_bool_exp
  country_id: uuid_comparison_exp
  created_at: timestamp_comparison_exp
  customer: customers_bool_exp
  customer_id: uuid_comparison_exp
  latitude: numeric_comparison_exp
  longitude: numeric_comparison_exp
}

# unique or primary key constraints on table "customers_address"
enum customers_address_constraint {
  # unique or primary key constraint
  customers_address_pkey
}

# input type for incrementing integer column in table "customers_address"
input customers_address_inc_input {
  latitude: numeric
  longitude: numeric
}

# input type for inserting data into table "customers_address"
input customers_address_insert_input {
  _id: uuid
  address: String
  city: cities_obj_rel_insert_input
  city_id: uuid
  country: countries_obj_rel_insert_input
  country_id: uuid
  created_at: timestamp
  customer: customers_obj_rel_insert_input
  customer_id: uuid
  latitude: numeric
  longitude: numeric
}

# aggregate max on columns
type customers_address_max_fields {
  _id: uuid
  address: String
  city_id: uuid
  country_id: uuid
  created_at: timestamp
  customer_id: uuid
  latitude: numeric
  longitude: numeric
}

# order by max() on columns of table "customers_address"
input customers_address_max_order_by {
  _id: order_by
  address: order_by
  city_id: order_by
  country_id: order_by
  created_at: order_by
  customer_id: order_by
  latitude: order_by
  longitude: order_by
}

# aggregate min on columns
type customers_address_min_fields {
  _id: uuid
  address: String
  city_id: uuid
  country_id: uuid
  created_at: timestamp
  customer_id: uuid
  latitude: numeric
  longitude: numeric
}

# order by min() on columns of table "customers_address"
input customers_address_min_order_by {
  _id: order_by
  address: order_by
  city_id: order_by
  country_id: order_by
  created_at: order_by
  customer_id: order_by
  latitude: order_by
  longitude: order_by
}

# response of any mutation on the table "customers_address"
type customers_address_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [customers_address!]!
}

# input type for inserting object relation for remote table "customers_address"
input customers_address_obj_rel_insert_input {
  data: customers_address_insert_input!
  on_conflict: customers_address_on_conflict
}

# on conflict condition type for table "customers_address"
input customers_address_on_conflict {
  constraint: customers_address_constraint!
  update_columns: [customers_address_update_column!]!
  where: customers_address_bool_exp
}

# ordering options when selecting data from "customers_address"
input customers_address_order_by {
  _id: order_by
  address: order_by
  city: cities_order_by
  city_id: order_by
  country: countries_order_by
  country_id: order_by
  created_at: order_by
  customer: customers_order_by
  customer_id: order_by
  latitude: order_by
  longitude: order_by
}

# primary key columns input for table: "customers_address"
input customers_address_pk_columns_input {
  _id: uuid!
}

# select columns of table "customers_address"
enum customers_address_select_column {
  # column name
  _id

  # column name
  address

  # column name
  city_id

  # column name
  country_id

  # column name
  created_at

  # column name
  customer_id

  # column name
  latitude

  # column name
  longitude
}

# input type for updating data in table "customers_address"
input customers_address_set_input {
  _id: uuid
  address: String
  city_id: uuid
  country_id: uuid
  created_at: timestamp
  customer_id: uuid
  latitude: numeric
  longitude: numeric
}

# aggregate stddev on columns
type customers_address_stddev_fields {
  latitude: Float
  longitude: Float
}

# order by stddev() on columns of table "customers_address"
input customers_address_stddev_order_by {
  latitude: order_by
  longitude: order_by
}

# aggregate stddev_pop on columns
type customers_address_stddev_pop_fields {
  latitude: Float
  longitude: Float
}

# order by stddev_pop() on columns of table "customers_address"
input customers_address_stddev_pop_order_by {
  latitude: order_by
  longitude: order_by
}

# aggregate stddev_samp on columns
type customers_address_stddev_samp_fields {
  latitude: Float
  longitude: Float
}

# order by stddev_samp() on columns of table "customers_address"
input customers_address_stddev_samp_order_by {
  latitude: order_by
  longitude: order_by
}

# aggregate sum on columns
type customers_address_sum_fields {
  latitude: numeric
  longitude: numeric
}

# order by sum() on columns of table "customers_address"
input customers_address_sum_order_by {
  latitude: order_by
  longitude: order_by
}

# update columns of table "customers_address"
enum customers_address_update_column {
  # column name
  _id

  # column name
  address

  # column name
  city_id

  # column name
  country_id

  # column name
  created_at

  # column name
  customer_id

  # column name
  latitude

  # column name
  longitude
}

# aggregate var_pop on columns
type customers_address_var_pop_fields {
  latitude: Float
  longitude: Float
}

# order by var_pop() on columns of table "customers_address"
input customers_address_var_pop_order_by {
  latitude: order_by
  longitude: order_by
}

# aggregate var_samp on columns
type customers_address_var_samp_fields {
  latitude: Float
  longitude: Float
}

# order by var_samp() on columns of table "customers_address"
input customers_address_var_samp_order_by {
  latitude: order_by
  longitude: order_by
}

# aggregate variance on columns
type customers_address_variance_fields {
  latitude: Float
  longitude: Float
}

# order by variance() on columns of table "customers_address"
input customers_address_variance_order_by {
  latitude: order_by
  longitude: order_by
}

# aggregated selection of "customers"
type customers_aggregate {
  aggregate: customers_aggregate_fields
  nodes: [customers!]!
}

# aggregate fields of "customers"
type customers_aggregate_fields {
  count(columns: [customers_select_column!], distinct: Boolean): Int
  max: customers_max_fields
  min: customers_min_fields
}

# order by aggregate values of table "customers"
input customers_aggregate_order_by {
  count: order_by
  max: customers_max_order_by
  min: customers_min_order_by
}

# input type for inserting array relation for remote table "customers"
input customers_arr_rel_insert_input {
  data: [customers_insert_input!]!
  on_conflict: customers_on_conflict
}

# Boolean expression to filter rows from the table "customers". All fields are combined with a logical 'AND'.
input customers_bool_exp {
  _and: [customers_bool_exp]
  _id: uuid_comparison_exp
  _not: customers_bool_exp
  _or: [customers_bool_exp]
  accept_emarketing: bit_comparison_exp
  created_at: timestamp_comparison_exp
  customers_addresses: customers_address_bool_exp
  customers_tags: customers_tags_bool_exp
  draft_orders: draft_orders_bool_exp
  email: String_comparison_exp
  first_name: String_comparison_exp
  last_name: String_comparison_exp
  orders: orders_bool_exp
  phone_number: String_comparison_exp
}

# unique or primary key constraints on table "customers"
enum customers_constraint {
  # unique or primary key constraint
  customers_email_key

  # unique or primary key constraint
  customers_pkey
}

# input type for inserting data into table "customers"
input customers_insert_input {
  _id: uuid
  accept_emarketing: bit
  created_at: timestamp
  customers_addresses: customers_address_arr_rel_insert_input
  customers_tags: customers_tags_arr_rel_insert_input
  draft_orders: draft_orders_arr_rel_insert_input
  email: String
  first_name: String
  last_name: String
  orders: orders_arr_rel_insert_input
  phone_number: String
}

# aggregate max on columns
type customers_max_fields {
  _id: uuid
  created_at: timestamp
  email: String
  first_name: String
  last_name: String
  phone_number: String
}

# order by max() on columns of table "customers"
input customers_max_order_by {
  _id: order_by
  created_at: order_by
  email: order_by
  first_name: order_by
  last_name: order_by
  phone_number: order_by
}

# aggregate min on columns
type customers_min_fields {
  _id: uuid
  created_at: timestamp
  email: String
  first_name: String
  last_name: String
  phone_number: String
}

# order by min() on columns of table "customers"
input customers_min_order_by {
  _id: order_by
  created_at: order_by
  email: order_by
  first_name: order_by
  last_name: order_by
  phone_number: order_by
}

# response of any mutation on the table "customers"
type customers_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [customers!]!
}

# input type for inserting object relation for remote table "customers"
input customers_obj_rel_insert_input {
  data: customers_insert_input!
  on_conflict: customers_on_conflict
}

# on conflict condition type for table "customers"
input customers_on_conflict {
  constraint: customers_constraint!
  update_columns: [customers_update_column!]!
  where: customers_bool_exp
}

# ordering options when selecting data from "customers"
input customers_order_by {
  _id: order_by
  accept_emarketing: order_by
  created_at: order_by
  customers_addresses_aggregate: customers_address_aggregate_order_by
  customers_tags_aggregate: customers_tags_aggregate_order_by
  draft_orders_aggregate: draft_orders_aggregate_order_by
  email: order_by
  first_name: order_by
  last_name: order_by
  orders_aggregate: orders_aggregate_order_by
  phone_number: order_by
}

# primary key columns input for table: "customers"
input customers_pk_columns_input {
  _id: uuid!
}

# select columns of table "customers"
enum customers_select_column {
  # column name
  _id

  # column name
  accept_emarketing

  # column name
  created_at

  # column name
  email

  # column name
  first_name

  # column name
  last_name

  # column name
  phone_number
}

# input type for updating data in table "customers"
input customers_set_input {
  _id: uuid
  accept_emarketing: bit
  created_at: timestamp
  email: String
  first_name: String
  last_name: String
  phone_number: String
}

# columns and relationships of "customers_tags"
type customers_tags {
  _id: uuid!
  costumer_id: uuid!
  created_at: timestamp

  # An object relationship
  customer: customers!
  tag: String
}

# aggregated selection of "customers_tags"
type customers_tags_aggregate {
  aggregate: customers_tags_aggregate_fields
  nodes: [customers_tags!]!
}

# aggregate fields of "customers_tags"
type customers_tags_aggregate_fields {
  count(columns: [customers_tags_select_column!], distinct: Boolean): Int
  max: customers_tags_max_fields
  min: customers_tags_min_fields
}

# order by aggregate values of table "customers_tags"
input customers_tags_aggregate_order_by {
  count: order_by
  max: customers_tags_max_order_by
  min: customers_tags_min_order_by
}

# input type for inserting array relation for remote table "customers_tags"
input customers_tags_arr_rel_insert_input {
  data: [customers_tags_insert_input!]!
  on_conflict: customers_tags_on_conflict
}

# Boolean expression to filter rows from the table "customers_tags". All fields are combined with a logical 'AND'.
input customers_tags_bool_exp {
  _and: [customers_tags_bool_exp]
  _id: uuid_comparison_exp
  _not: customers_tags_bool_exp
  _or: [customers_tags_bool_exp]
  costumer_id: uuid_comparison_exp
  created_at: timestamp_comparison_exp
  customer: customers_bool_exp
  tag: String_comparison_exp
}

# unique or primary key constraints on table "customers_tags"
enum customers_tags_constraint {
  # unique or primary key constraint
  customers_tags_pkey
}

# input type for inserting data into table "customers_tags"
input customers_tags_insert_input {
  _id: uuid
  costumer_id: uuid
  created_at: timestamp
  customer: customers_obj_rel_insert_input
  tag: String
}

# aggregate max on columns
type customers_tags_max_fields {
  _id: uuid
  costumer_id: uuid
  created_at: timestamp
  tag: String
}

# order by max() on columns of table "customers_tags"
input customers_tags_max_order_by {
  _id: order_by
  costumer_id: order_by
  created_at: order_by
  tag: order_by
}

# aggregate min on columns
type customers_tags_min_fields {
  _id: uuid
  costumer_id: uuid
  created_at: timestamp
  tag: String
}

# order by min() on columns of table "customers_tags"
input customers_tags_min_order_by {
  _id: order_by
  costumer_id: order_by
  created_at: order_by
  tag: order_by
}

# response of any mutation on the table "customers_tags"
type customers_tags_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [customers_tags!]!
}

# input type for inserting object relation for remote table "customers_tags"
input customers_tags_obj_rel_insert_input {
  data: customers_tags_insert_input!
  on_conflict: customers_tags_on_conflict
}

# on conflict condition type for table "customers_tags"
input customers_tags_on_conflict {
  constraint: customers_tags_constraint!
  update_columns: [customers_tags_update_column!]!
  where: customers_tags_bool_exp
}

# ordering options when selecting data from "customers_tags"
input customers_tags_order_by {
  _id: order_by
  costumer_id: order_by
  created_at: order_by
  customer: customers_order_by
  tag: order_by
}

# primary key columns input for table: "customers_tags"
input customers_tags_pk_columns_input {
  _id: uuid!
}

# select columns of table "customers_tags"
enum customers_tags_select_column {
  # column name
  _id

  # column name
  costumer_id

  # column name
  created_at

  # column name
  tag
}

# input type for updating data in table "customers_tags"
input customers_tags_set_input {
  _id: uuid
  costumer_id: uuid
  created_at: timestamp
  tag: String
}

# update columns of table "customers_tags"
enum customers_tags_update_column {
  # column name
  _id

  # column name
  costumer_id

  # column name
  created_at

  # column name
  tag
}

# update columns of table "customers"
enum customers_update_column {
  # column name
  _id

  # column name
  accept_emarketing

  # column name
  created_at

  # column name
  email

  # column name
  first_name

  # column name
  last_name

  # column name
  phone_number
}

# columns and relationships of "draft_orders"
type draft_orders {
  _id: uuid!
  created_at: timestamp

  # An object relationship
  customer: customers!
  customer_id: uuid!

  # An array relationship
  draft_orders_details(
    # distinct select on columns
    distinct_on: [draft_orders_details_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [draft_orders_details_order_by!]

    # filter the rows returned
    where: draft_orders_details_bool_exp
  ): [draft_orders_details!]!

  # An aggregated array relationship
  draft_orders_details_aggregate(
    # distinct select on columns
    distinct_on: [draft_orders_details_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [draft_orders_details_order_by!]

    # filter the rows returned
    where: draft_orders_details_bool_exp
  ): draft_orders_details_aggregate!
  entry_date: timestamp

  # An object relationship
  store: stores!
  store_id: uuid!
  sub_total: numeric!
  tax_total: numeric!
  total: numeric
}

# aggregated selection of "draft_orders"
type draft_orders_aggregate {
  aggregate: draft_orders_aggregate_fields
  nodes: [draft_orders!]!
}

# aggregate fields of "draft_orders"
type draft_orders_aggregate_fields {
  avg: draft_orders_avg_fields
  count(columns: [draft_orders_select_column!], distinct: Boolean): Int
  max: draft_orders_max_fields
  min: draft_orders_min_fields
  stddev: draft_orders_stddev_fields
  stddev_pop: draft_orders_stddev_pop_fields
  stddev_samp: draft_orders_stddev_samp_fields
  sum: draft_orders_sum_fields
  var_pop: draft_orders_var_pop_fields
  var_samp: draft_orders_var_samp_fields
  variance: draft_orders_variance_fields
}

# order by aggregate values of table "draft_orders"
input draft_orders_aggregate_order_by {
  avg: draft_orders_avg_order_by
  count: order_by
  max: draft_orders_max_order_by
  min: draft_orders_min_order_by
  stddev: draft_orders_stddev_order_by
  stddev_pop: draft_orders_stddev_pop_order_by
  stddev_samp: draft_orders_stddev_samp_order_by
  sum: draft_orders_sum_order_by
  var_pop: draft_orders_var_pop_order_by
  var_samp: draft_orders_var_samp_order_by
  variance: draft_orders_variance_order_by
}

# input type for inserting array relation for remote table "draft_orders"
input draft_orders_arr_rel_insert_input {
  data: [draft_orders_insert_input!]!
  on_conflict: draft_orders_on_conflict
}

# aggregate avg on columns
type draft_orders_avg_fields {
  sub_total: Float
  tax_total: Float
  total: Float
}

# order by avg() on columns of table "draft_orders"
input draft_orders_avg_order_by {
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# Boolean expression to filter rows from the table "draft_orders". All fields are combined with a logical 'AND'.
input draft_orders_bool_exp {
  _and: [draft_orders_bool_exp]
  _id: uuid_comparison_exp
  _not: draft_orders_bool_exp
  _or: [draft_orders_bool_exp]
  created_at: timestamp_comparison_exp
  customer: customers_bool_exp
  customer_id: uuid_comparison_exp
  draft_orders_details: draft_orders_details_bool_exp
  entry_date: timestamp_comparison_exp
  store: stores_bool_exp
  store_id: uuid_comparison_exp
  sub_total: numeric_comparison_exp
  tax_total: numeric_comparison_exp
  total: numeric_comparison_exp
}

# unique or primary key constraints on table "draft_orders"
enum draft_orders_constraint {
  # unique or primary key constraint
  draft_orders_pkey
}

# columns and relationships of "draft_orders_details"
type draft_orders_details {
  _id: uuid!
  created_at: timestamp
  discount_total: numeric

  # An object relationship
  draft_order: draft_orders!
  draft_order_id: uuid!
  price: numeric
  product_lot_id: uuid!

  # An object relationship
  products_lot: products_lots!
  quantity: Int
  sub_total: numeric
  tax_total: numeric
  total: numeric
}

# aggregated selection of "draft_orders_details"
type draft_orders_details_aggregate {
  aggregate: draft_orders_details_aggregate_fields
  nodes: [draft_orders_details!]!
}

# aggregate fields of "draft_orders_details"
type draft_orders_details_aggregate_fields {
  avg: draft_orders_details_avg_fields
  count(columns: [draft_orders_details_select_column!], distinct: Boolean): Int
  max: draft_orders_details_max_fields
  min: draft_orders_details_min_fields
  stddev: draft_orders_details_stddev_fields
  stddev_pop: draft_orders_details_stddev_pop_fields
  stddev_samp: draft_orders_details_stddev_samp_fields
  sum: draft_orders_details_sum_fields
  var_pop: draft_orders_details_var_pop_fields
  var_samp: draft_orders_details_var_samp_fields
  variance: draft_orders_details_variance_fields
}

# order by aggregate values of table "draft_orders_details"
input draft_orders_details_aggregate_order_by {
  avg: draft_orders_details_avg_order_by
  count: order_by
  max: draft_orders_details_max_order_by
  min: draft_orders_details_min_order_by
  stddev: draft_orders_details_stddev_order_by
  stddev_pop: draft_orders_details_stddev_pop_order_by
  stddev_samp: draft_orders_details_stddev_samp_order_by
  sum: draft_orders_details_sum_order_by
  var_pop: draft_orders_details_var_pop_order_by
  var_samp: draft_orders_details_var_samp_order_by
  variance: draft_orders_details_variance_order_by
}

# input type for inserting array relation for remote table "draft_orders_details"
input draft_orders_details_arr_rel_insert_input {
  data: [draft_orders_details_insert_input!]!
  on_conflict: draft_orders_details_on_conflict
}

# aggregate avg on columns
type draft_orders_details_avg_fields {
  discount_total: Float
  price: Float
  quantity: Float
  sub_total: Float
  tax_total: Float
  total: Float
}

# order by avg() on columns of table "draft_orders_details"
input draft_orders_details_avg_order_by {
  discount_total: order_by
  price: order_by
  quantity: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# Boolean expression to filter rows from the table "draft_orders_details". All fields are combined with a logical 'AND'.
input draft_orders_details_bool_exp {
  _and: [draft_orders_details_bool_exp]
  _id: uuid_comparison_exp
  _not: draft_orders_details_bool_exp
  _or: [draft_orders_details_bool_exp]
  created_at: timestamp_comparison_exp
  discount_total: numeric_comparison_exp
  draft_order: draft_orders_bool_exp
  draft_order_id: uuid_comparison_exp
  price: numeric_comparison_exp
  product_lot_id: uuid_comparison_exp
  products_lot: products_lots_bool_exp
  quantity: Int_comparison_exp
  sub_total: numeric_comparison_exp
  tax_total: numeric_comparison_exp
  total: numeric_comparison_exp
}

# unique or primary key constraints on table "draft_orders_details"
enum draft_orders_details_constraint {
  # unique or primary key constraint
  draft_orders_details_pkey
}

# input type for incrementing integer column in table "draft_orders_details"
input draft_orders_details_inc_input {
  discount_total: numeric
  price: numeric
  quantity: Int
  sub_total: numeric
  tax_total: numeric
  total: numeric
}

# input type for inserting data into table "draft_orders_details"
input draft_orders_details_insert_input {
  _id: uuid
  created_at: timestamp
  discount_total: numeric
  draft_order: draft_orders_obj_rel_insert_input
  draft_order_id: uuid
  price: numeric
  product_lot_id: uuid
  products_lot: products_lots_obj_rel_insert_input
  quantity: Int
  sub_total: numeric
  tax_total: numeric
  total: numeric
}

# aggregate max on columns
type draft_orders_details_max_fields {
  _id: uuid
  created_at: timestamp
  discount_total: numeric
  draft_order_id: uuid
  price: numeric
  product_lot_id: uuid
  quantity: Int
  sub_total: numeric
  tax_total: numeric
  total: numeric
}

# order by max() on columns of table "draft_orders_details"
input draft_orders_details_max_order_by {
  _id: order_by
  created_at: order_by
  discount_total: order_by
  draft_order_id: order_by
  price: order_by
  product_lot_id: order_by
  quantity: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# aggregate min on columns
type draft_orders_details_min_fields {
  _id: uuid
  created_at: timestamp
  discount_total: numeric
  draft_order_id: uuid
  price: numeric
  product_lot_id: uuid
  quantity: Int
  sub_total: numeric
  tax_total: numeric
  total: numeric
}

# order by min() on columns of table "draft_orders_details"
input draft_orders_details_min_order_by {
  _id: order_by
  created_at: order_by
  discount_total: order_by
  draft_order_id: order_by
  price: order_by
  product_lot_id: order_by
  quantity: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# response of any mutation on the table "draft_orders_details"
type draft_orders_details_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [draft_orders_details!]!
}

# input type for inserting object relation for remote table "draft_orders_details"
input draft_orders_details_obj_rel_insert_input {
  data: draft_orders_details_insert_input!
  on_conflict: draft_orders_details_on_conflict
}

# on conflict condition type for table "draft_orders_details"
input draft_orders_details_on_conflict {
  constraint: draft_orders_details_constraint!
  update_columns: [draft_orders_details_update_column!]!
  where: draft_orders_details_bool_exp
}

# ordering options when selecting data from "draft_orders_details"
input draft_orders_details_order_by {
  _id: order_by
  created_at: order_by
  discount_total: order_by
  draft_order: draft_orders_order_by
  draft_order_id: order_by
  price: order_by
  product_lot_id: order_by
  products_lot: products_lots_order_by
  quantity: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# primary key columns input for table: "draft_orders_details"
input draft_orders_details_pk_columns_input {
  _id: uuid!
}

# select columns of table "draft_orders_details"
enum draft_orders_details_select_column {
  # column name
  _id

  # column name
  created_at

  # column name
  discount_total

  # column name
  draft_order_id

  # column name
  price

  # column name
  product_lot_id

  # column name
  quantity

  # column name
  sub_total

  # column name
  tax_total

  # column name
  total
}

# input type for updating data in table "draft_orders_details"
input draft_orders_details_set_input {
  _id: uuid
  created_at: timestamp
  discount_total: numeric
  draft_order_id: uuid
  price: numeric
  product_lot_id: uuid
  quantity: Int
  sub_total: numeric
  tax_total: numeric
  total: numeric
}

# aggregate stddev on columns
type draft_orders_details_stddev_fields {
  discount_total: Float
  price: Float
  quantity: Float
  sub_total: Float
  tax_total: Float
  total: Float
}

# order by stddev() on columns of table "draft_orders_details"
input draft_orders_details_stddev_order_by {
  discount_total: order_by
  price: order_by
  quantity: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# aggregate stddev_pop on columns
type draft_orders_details_stddev_pop_fields {
  discount_total: Float
  price: Float
  quantity: Float
  sub_total: Float
  tax_total: Float
  total: Float
}

# order by stddev_pop() on columns of table "draft_orders_details"
input draft_orders_details_stddev_pop_order_by {
  discount_total: order_by
  price: order_by
  quantity: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# aggregate stddev_samp on columns
type draft_orders_details_stddev_samp_fields {
  discount_total: Float
  price: Float
  quantity: Float
  sub_total: Float
  tax_total: Float
  total: Float
}

# order by stddev_samp() on columns of table "draft_orders_details"
input draft_orders_details_stddev_samp_order_by {
  discount_total: order_by
  price: order_by
  quantity: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# aggregate sum on columns
type draft_orders_details_sum_fields {
  discount_total: numeric
  price: numeric
  quantity: Int
  sub_total: numeric
  tax_total: numeric
  total: numeric
}

# order by sum() on columns of table "draft_orders_details"
input draft_orders_details_sum_order_by {
  discount_total: order_by
  price: order_by
  quantity: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# update columns of table "draft_orders_details"
enum draft_orders_details_update_column {
  # column name
  _id

  # column name
  created_at

  # column name
  discount_total

  # column name
  draft_order_id

  # column name
  price

  # column name
  product_lot_id

  # column name
  quantity

  # column name
  sub_total

  # column name
  tax_total

  # column name
  total
}

# aggregate var_pop on columns
type draft_orders_details_var_pop_fields {
  discount_total: Float
  price: Float
  quantity: Float
  sub_total: Float
  tax_total: Float
  total: Float
}

# order by var_pop() on columns of table "draft_orders_details"
input draft_orders_details_var_pop_order_by {
  discount_total: order_by
  price: order_by
  quantity: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# aggregate var_samp on columns
type draft_orders_details_var_samp_fields {
  discount_total: Float
  price: Float
  quantity: Float
  sub_total: Float
  tax_total: Float
  total: Float
}

# order by var_samp() on columns of table "draft_orders_details"
input draft_orders_details_var_samp_order_by {
  discount_total: order_by
  price: order_by
  quantity: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# aggregate variance on columns
type draft_orders_details_variance_fields {
  discount_total: Float
  price: Float
  quantity: Float
  sub_total: Float
  tax_total: Float
  total: Float
}

# order by variance() on columns of table "draft_orders_details"
input draft_orders_details_variance_order_by {
  discount_total: order_by
  price: order_by
  quantity: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# input type for incrementing integer column in table "draft_orders"
input draft_orders_inc_input {
  sub_total: numeric
  tax_total: numeric
  total: numeric
}

# input type for inserting data into table "draft_orders"
input draft_orders_insert_input {
  _id: uuid
  created_at: timestamp
  customer: customers_obj_rel_insert_input
  customer_id: uuid
  draft_orders_details: draft_orders_details_arr_rel_insert_input
  entry_date: timestamp
  store: stores_obj_rel_insert_input
  store_id: uuid
  sub_total: numeric
  tax_total: numeric
  total: numeric
}

# aggregate max on columns
type draft_orders_max_fields {
  _id: uuid
  created_at: timestamp
  customer_id: uuid
  entry_date: timestamp
  store_id: uuid
  sub_total: numeric
  tax_total: numeric
  total: numeric
}

# order by max() on columns of table "draft_orders"
input draft_orders_max_order_by {
  _id: order_by
  created_at: order_by
  customer_id: order_by
  entry_date: order_by
  store_id: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# aggregate min on columns
type draft_orders_min_fields {
  _id: uuid
  created_at: timestamp
  customer_id: uuid
  entry_date: timestamp
  store_id: uuid
  sub_total: numeric
  tax_total: numeric
  total: numeric
}

# order by min() on columns of table "draft_orders"
input draft_orders_min_order_by {
  _id: order_by
  created_at: order_by
  customer_id: order_by
  entry_date: order_by
  store_id: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# response of any mutation on the table "draft_orders"
type draft_orders_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [draft_orders!]!
}

# input type for inserting object relation for remote table "draft_orders"
input draft_orders_obj_rel_insert_input {
  data: draft_orders_insert_input!
  on_conflict: draft_orders_on_conflict
}

# on conflict condition type for table "draft_orders"
input draft_orders_on_conflict {
  constraint: draft_orders_constraint!
  update_columns: [draft_orders_update_column!]!
  where: draft_orders_bool_exp
}

# ordering options when selecting data from "draft_orders"
input draft_orders_order_by {
  _id: order_by
  created_at: order_by
  customer: customers_order_by
  customer_id: order_by
  draft_orders_details_aggregate: draft_orders_details_aggregate_order_by
  entry_date: order_by
  store: stores_order_by
  store_id: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# primary key columns input for table: "draft_orders"
input draft_orders_pk_columns_input {
  _id: uuid!
}

# select columns of table "draft_orders"
enum draft_orders_select_column {
  # column name
  _id

  # column name
  created_at

  # column name
  customer_id

  # column name
  entry_date

  # column name
  store_id

  # column name
  sub_total

  # column name
  tax_total

  # column name
  total
}

# input type for updating data in table "draft_orders"
input draft_orders_set_input {
  _id: uuid
  created_at: timestamp
  customer_id: uuid
  entry_date: timestamp
  store_id: uuid
  sub_total: numeric
  tax_total: numeric
  total: numeric
}

# aggregate stddev on columns
type draft_orders_stddev_fields {
  sub_total: Float
  tax_total: Float
  total: Float
}

# order by stddev() on columns of table "draft_orders"
input draft_orders_stddev_order_by {
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# aggregate stddev_pop on columns
type draft_orders_stddev_pop_fields {
  sub_total: Float
  tax_total: Float
  total: Float
}

# order by stddev_pop() on columns of table "draft_orders"
input draft_orders_stddev_pop_order_by {
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# aggregate stddev_samp on columns
type draft_orders_stddev_samp_fields {
  sub_total: Float
  tax_total: Float
  total: Float
}

# order by stddev_samp() on columns of table "draft_orders"
input draft_orders_stddev_samp_order_by {
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# aggregate sum on columns
type draft_orders_sum_fields {
  sub_total: numeric
  tax_total: numeric
  total: numeric
}

# order by sum() on columns of table "draft_orders"
input draft_orders_sum_order_by {
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# update columns of table "draft_orders"
enum draft_orders_update_column {
  # column name
  _id

  # column name
  created_at

  # column name
  customer_id

  # column name
  entry_date

  # column name
  store_id

  # column name
  sub_total

  # column name
  tax_total

  # column name
  total
}

# aggregate var_pop on columns
type draft_orders_var_pop_fields {
  sub_total: Float
  tax_total: Float
  total: Float
}

# order by var_pop() on columns of table "draft_orders"
input draft_orders_var_pop_order_by {
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# aggregate var_samp on columns
type draft_orders_var_samp_fields {
  sub_total: Float
  tax_total: Float
  total: Float
}

# order by var_samp() on columns of table "draft_orders"
input draft_orders_var_samp_order_by {
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# aggregate variance on columns
type draft_orders_variance_fields {
  sub_total: Float
  tax_total: Float
  total: Float
}

# order by variance() on columns of table "draft_orders"
input draft_orders_variance_order_by {
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# expression to compare columns of type Int. All fields are combined with logical 'AND'.
input Int_comparison_exp {
  _eq: Int
  _gt: Int
  _gte: Int
  _in: [Int!]
  _is_null: Boolean
  _lt: Int
  _lte: Int
  _neq: Int
  _nin: [Int!]
}

# columns and relationships of "kardex"
type kardex {
  _id: uuid!
  created_at: timestamp
  product_lot_id: uuid!

  # An object relationship
  products_lot: products_lots!
  quantity: numeric
  type_movement_id: uuid!

  # An object relationship
  types_movement: types_movements!
}

# aggregated selection of "kardex"
type kardex_aggregate {
  aggregate: kardex_aggregate_fields
  nodes: [kardex!]!
}

# aggregate fields of "kardex"
type kardex_aggregate_fields {
  avg: kardex_avg_fields
  count(columns: [kardex_select_column!], distinct: Boolean): Int
  max: kardex_max_fields
  min: kardex_min_fields
  stddev: kardex_stddev_fields
  stddev_pop: kardex_stddev_pop_fields
  stddev_samp: kardex_stddev_samp_fields
  sum: kardex_sum_fields
  var_pop: kardex_var_pop_fields
  var_samp: kardex_var_samp_fields
  variance: kardex_variance_fields
}

# order by aggregate values of table "kardex"
input kardex_aggregate_order_by {
  avg: kardex_avg_order_by
  count: order_by
  max: kardex_max_order_by
  min: kardex_min_order_by
  stddev: kardex_stddev_order_by
  stddev_pop: kardex_stddev_pop_order_by
  stddev_samp: kardex_stddev_samp_order_by
  sum: kardex_sum_order_by
  var_pop: kardex_var_pop_order_by
  var_samp: kardex_var_samp_order_by
  variance: kardex_variance_order_by
}

# input type for inserting array relation for remote table "kardex"
input kardex_arr_rel_insert_input {
  data: [kardex_insert_input!]!
  on_conflict: kardex_on_conflict
}

# aggregate avg on columns
type kardex_avg_fields {
  quantity: Float
}

# order by avg() on columns of table "kardex"
input kardex_avg_order_by {
  quantity: order_by
}

# Boolean expression to filter rows from the table "kardex". All fields are combined with a logical 'AND'.
input kardex_bool_exp {
  _and: [kardex_bool_exp]
  _id: uuid_comparison_exp
  _not: kardex_bool_exp
  _or: [kardex_bool_exp]
  created_at: timestamp_comparison_exp
  product_lot_id: uuid_comparison_exp
  products_lot: products_lots_bool_exp
  quantity: numeric_comparison_exp
  type_movement_id: uuid_comparison_exp
  types_movement: types_movements_bool_exp
}

# unique or primary key constraints on table "kardex"
enum kardex_constraint {
  # unique or primary key constraint
  kardex_pkey
}

# input type for incrementing integer column in table "kardex"
input kardex_inc_input {
  quantity: numeric
}

# input type for inserting data into table "kardex"
input kardex_insert_input {
  _id: uuid
  created_at: timestamp
  product_lot_id: uuid
  products_lot: products_lots_obj_rel_insert_input
  quantity: numeric
  type_movement_id: uuid
  types_movement: types_movements_obj_rel_insert_input
}

# aggregate max on columns
type kardex_max_fields {
  _id: uuid
  created_at: timestamp
  product_lot_id: uuid
  quantity: numeric
  type_movement_id: uuid
}

# order by max() on columns of table "kardex"
input kardex_max_order_by {
  _id: order_by
  created_at: order_by
  product_lot_id: order_by
  quantity: order_by
  type_movement_id: order_by
}

# aggregate min on columns
type kardex_min_fields {
  _id: uuid
  created_at: timestamp
  product_lot_id: uuid
  quantity: numeric
  type_movement_id: uuid
}

# order by min() on columns of table "kardex"
input kardex_min_order_by {
  _id: order_by
  created_at: order_by
  product_lot_id: order_by
  quantity: order_by
  type_movement_id: order_by
}

# response of any mutation on the table "kardex"
type kardex_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [kardex!]!
}

# input type for inserting object relation for remote table "kardex"
input kardex_obj_rel_insert_input {
  data: kardex_insert_input!
  on_conflict: kardex_on_conflict
}

# on conflict condition type for table "kardex"
input kardex_on_conflict {
  constraint: kardex_constraint!
  update_columns: [kardex_update_column!]!
  where: kardex_bool_exp
}

# ordering options when selecting data from "kardex"
input kardex_order_by {
  _id: order_by
  created_at: order_by
  product_lot_id: order_by
  products_lot: products_lots_order_by
  quantity: order_by
  type_movement_id: order_by
  types_movement: types_movements_order_by
}

# primary key columns input for table: "kardex"
input kardex_pk_columns_input {
  _id: uuid!
}

# select columns of table "kardex"
enum kardex_select_column {
  # column name
  _id

  # column name
  created_at

  # column name
  product_lot_id

  # column name
  quantity

  # column name
  type_movement_id
}

# input type for updating data in table "kardex"
input kardex_set_input {
  _id: uuid
  created_at: timestamp
  product_lot_id: uuid
  quantity: numeric
  type_movement_id: uuid
}

# aggregate stddev on columns
type kardex_stddev_fields {
  quantity: Float
}

# order by stddev() on columns of table "kardex"
input kardex_stddev_order_by {
  quantity: order_by
}

# aggregate stddev_pop on columns
type kardex_stddev_pop_fields {
  quantity: Float
}

# order by stddev_pop() on columns of table "kardex"
input kardex_stddev_pop_order_by {
  quantity: order_by
}

# aggregate stddev_samp on columns
type kardex_stddev_samp_fields {
  quantity: Float
}

# order by stddev_samp() on columns of table "kardex"
input kardex_stddev_samp_order_by {
  quantity: order_by
}

# aggregate sum on columns
type kardex_sum_fields {
  quantity: numeric
}

# order by sum() on columns of table "kardex"
input kardex_sum_order_by {
  quantity: order_by
}

# update columns of table "kardex"
enum kardex_update_column {
  # column name
  _id

  # column name
  created_at

  # column name
  product_lot_id

  # column name
  quantity

  # column name
  type_movement_id
}

# aggregate var_pop on columns
type kardex_var_pop_fields {
  quantity: Float
}

# order by var_pop() on columns of table "kardex"
input kardex_var_pop_order_by {
  quantity: order_by
}

# aggregate var_samp on columns
type kardex_var_samp_fields {
  quantity: Float
}

# order by var_samp() on columns of table "kardex"
input kardex_var_samp_order_by {
  quantity: order_by
}

# aggregate variance on columns
type kardex_variance_fields {
  quantity: Float
}

# order by variance() on columns of table "kardex"
input kardex_variance_order_by {
  quantity: order_by
}

# mutation root
type mutation_root {
  # delete data from the table: "cities"
  delete_cities(
    # filter the rows which have to be deleted
    where: cities_bool_exp!
  ): cities_mutation_response

  # delete single row from the table: "cities"
  delete_cities_by_pk(_id: uuid!): cities

  # delete data from the table: "countries"
  delete_countries(
    # filter the rows which have to be deleted
    where: countries_bool_exp!
  ): countries_mutation_response

  # delete single row from the table: "countries"
  delete_countries_by_pk(_id: uuid!): countries

  # delete data from the table: "countries_currency"
  delete_countries_currency(
    # filter the rows which have to be deleted
    where: countries_currency_bool_exp!
  ): countries_currency_mutation_response

  # delete single row from the table: "countries_currency"
  delete_countries_currency_by_pk(_id: uuid!): countries_currency

  # delete data from the table: "countries_taxes"
  delete_countries_taxes(
    # filter the rows which have to be deleted
    where: countries_taxes_bool_exp!
  ): countries_taxes_mutation_response

  # delete single row from the table: "countries_taxes"
  delete_countries_taxes_by_pk(_id: uuid!): countries_taxes

  # delete data from the table: "customers"
  delete_customers(
    # filter the rows which have to be deleted
    where: customers_bool_exp!
  ): customers_mutation_response

  # delete data from the table: "customers_address"
  delete_customers_address(
    # filter the rows which have to be deleted
    where: customers_address_bool_exp!
  ): customers_address_mutation_response

  # delete single row from the table: "customers_address"
  delete_customers_address_by_pk(_id: uuid!): customers_address

  # delete single row from the table: "customers"
  delete_customers_by_pk(_id: uuid!): customers

  # delete data from the table: "customers_tags"
  delete_customers_tags(
    # filter the rows which have to be deleted
    where: customers_tags_bool_exp!
  ): customers_tags_mutation_response

  # delete single row from the table: "customers_tags"
  delete_customers_tags_by_pk(_id: uuid!): customers_tags

  # delete data from the table: "draft_orders"
  delete_draft_orders(
    # filter the rows which have to be deleted
    where: draft_orders_bool_exp!
  ): draft_orders_mutation_response

  # delete single row from the table: "draft_orders"
  delete_draft_orders_by_pk(_id: uuid!): draft_orders

  # delete data from the table: "draft_orders_details"
  delete_draft_orders_details(
    # filter the rows which have to be deleted
    where: draft_orders_details_bool_exp!
  ): draft_orders_details_mutation_response

  # delete single row from the table: "draft_orders_details"
  delete_draft_orders_details_by_pk(_id: uuid!): draft_orders_details

  # delete data from the table: "kardex"
  delete_kardex(
    # filter the rows which have to be deleted
    where: kardex_bool_exp!
  ): kardex_mutation_response

  # delete single row from the table: "kardex"
  delete_kardex_by_pk(_id: uuid!): kardex

  # delete data from the table: "orders"
  delete_orders(
    # filter the rows which have to be deleted
    where: orders_bool_exp!
  ): orders_mutation_response

  # delete single row from the table: "orders"
  delete_orders_by_pk(_id: uuid!): orders

  # delete data from the table: "orders_details"
  delete_orders_details(
    # filter the rows which have to be deleted
    where: orders_details_bool_exp!
  ): orders_details_mutation_response

  # delete single row from the table: "orders_details"
  delete_orders_details_by_pk(_id: uuid!): orders_details

  # delete data from the table: "price_rule"
  delete_price_rule(
    # filter the rows which have to be deleted
    where: price_rule_bool_exp!
  ): price_rule_mutation_response

  # delete single row from the table: "price_rule"
  delete_price_rule_by_pk(_id: uuid!): price_rule

  # delete data from the table: "products"
  delete_products(
    # filter the rows which have to be deleted
    where: products_bool_exp!
  ): products_mutation_response

  # delete single row from the table: "products"
  delete_products_by_pk(_id: uuid!): products

  # delete data from the table: "products_categories"
  delete_products_categories(
    # filter the rows which have to be deleted
    where: products_categories_bool_exp!
  ): products_categories_mutation_response

  # delete single row from the table: "products_categories"
  delete_products_categories_by_pk(_id: uuid!): products_categories

  # delete data from the table: "products_lots"
  delete_products_lots(
    # filter the rows which have to be deleted
    where: products_lots_bool_exp!
  ): products_lots_mutation_response

  # delete single row from the table: "products_lots"
  delete_products_lots_by_pk(_id: uuid!): products_lots

  # delete data from the table: "products_media"
  delete_products_media(
    # filter the rows which have to be deleted
    where: products_media_bool_exp!
  ): products_media_mutation_response

  # delete single row from the table: "products_media"
  delete_products_media_by_pk(_id: uuid!): products_media

  # delete data from the table: "products_tags"
  delete_products_tags(
    # filter the rows which have to be deleted
    where: products_tags_bool_exp!
  ): products_tags_mutation_response

  # delete single row from the table: "products_tags"
  delete_products_tags_by_pk(_id: uuid!): products_tags

  # delete data from the table: "stores"
  delete_stores(
    # filter the rows which have to be deleted
    where: stores_bool_exp!
  ): stores_mutation_response

  # delete single row from the table: "stores"
  delete_stores_by_pk(_id: uuid!): stores

  # delete data from the table: "stores_categories"
  delete_stores_categories(
    # filter the rows which have to be deleted
    where: stores_categories_bool_exp!
  ): stores_categories_mutation_response

  # delete single row from the table: "stores_categories"
  delete_stores_categories_by_pk(_id: uuid!): stores_categories

  # delete data from the table: "types_movements"
  delete_types_movements(
    # filter the rows which have to be deleted
    where: types_movements_bool_exp!
  ): types_movements_mutation_response

  # delete single row from the table: "types_movements"
  delete_types_movements_by_pk(_id: uuid!): types_movements

  # delete data from the table: "users"
  delete_users(
    # filter the rows which have to be deleted
    where: users_bool_exp!
  ): users_mutation_response

  # delete single row from the table: "users"
  delete_users_by_pk(_id: uuid!): users

  # insert data into the table: "cities"
  insert_cities(
    # the rows to be inserted
    objects: [cities_insert_input!]!

    # on conflict condition
    on_conflict: cities_on_conflict
  ): cities_mutation_response

  # insert a single row into the table: "cities"
  insert_cities_one(
    # the row to be inserted
    object: cities_insert_input!

    # on conflict condition
    on_conflict: cities_on_conflict
  ): cities

  # insert data into the table: "countries"
  insert_countries(
    # the rows to be inserted
    objects: [countries_insert_input!]!

    # on conflict condition
    on_conflict: countries_on_conflict
  ): countries_mutation_response

  # insert data into the table: "countries_currency"
  insert_countries_currency(
    # the rows to be inserted
    objects: [countries_currency_insert_input!]!

    # on conflict condition
    on_conflict: countries_currency_on_conflict
  ): countries_currency_mutation_response

  # insert a single row into the table: "countries_currency"
  insert_countries_currency_one(
    # the row to be inserted
    object: countries_currency_insert_input!

    # on conflict condition
    on_conflict: countries_currency_on_conflict
  ): countries_currency

  # insert a single row into the table: "countries"
  insert_countries_one(
    # the row to be inserted
    object: countries_insert_input!

    # on conflict condition
    on_conflict: countries_on_conflict
  ): countries

  # insert data into the table: "countries_taxes"
  insert_countries_taxes(
    # the rows to be inserted
    objects: [countries_taxes_insert_input!]!

    # on conflict condition
    on_conflict: countries_taxes_on_conflict
  ): countries_taxes_mutation_response

  # insert a single row into the table: "countries_taxes"
  insert_countries_taxes_one(
    # the row to be inserted
    object: countries_taxes_insert_input!

    # on conflict condition
    on_conflict: countries_taxes_on_conflict
  ): countries_taxes

  # insert data into the table: "customers"
  insert_customers(
    # the rows to be inserted
    objects: [customers_insert_input!]!

    # on conflict condition
    on_conflict: customers_on_conflict
  ): customers_mutation_response

  # insert data into the table: "customers_address"
  insert_customers_address(
    # the rows to be inserted
    objects: [customers_address_insert_input!]!

    # on conflict condition
    on_conflict: customers_address_on_conflict
  ): customers_address_mutation_response

  # insert a single row into the table: "customers_address"
  insert_customers_address_one(
    # the row to be inserted
    object: customers_address_insert_input!

    # on conflict condition
    on_conflict: customers_address_on_conflict
  ): customers_address

  # insert a single row into the table: "customers"
  insert_customers_one(
    # the row to be inserted
    object: customers_insert_input!

    # on conflict condition
    on_conflict: customers_on_conflict
  ): customers

  # insert data into the table: "customers_tags"
  insert_customers_tags(
    # the rows to be inserted
    objects: [customers_tags_insert_input!]!

    # on conflict condition
    on_conflict: customers_tags_on_conflict
  ): customers_tags_mutation_response

  # insert a single row into the table: "customers_tags"
  insert_customers_tags_one(
    # the row to be inserted
    object: customers_tags_insert_input!

    # on conflict condition
    on_conflict: customers_tags_on_conflict
  ): customers_tags

  # insert data into the table: "draft_orders"
  insert_draft_orders(
    # the rows to be inserted
    objects: [draft_orders_insert_input!]!

    # on conflict condition
    on_conflict: draft_orders_on_conflict
  ): draft_orders_mutation_response

  # insert data into the table: "draft_orders_details"
  insert_draft_orders_details(
    # the rows to be inserted
    objects: [draft_orders_details_insert_input!]!

    # on conflict condition
    on_conflict: draft_orders_details_on_conflict
  ): draft_orders_details_mutation_response

  # insert a single row into the table: "draft_orders_details"
  insert_draft_orders_details_one(
    # the row to be inserted
    object: draft_orders_details_insert_input!

    # on conflict condition
    on_conflict: draft_orders_details_on_conflict
  ): draft_orders_details

  # insert a single row into the table: "draft_orders"
  insert_draft_orders_one(
    # the row to be inserted
    object: draft_orders_insert_input!

    # on conflict condition
    on_conflict: draft_orders_on_conflict
  ): draft_orders

  # insert data into the table: "kardex"
  insert_kardex(
    # the rows to be inserted
    objects: [kardex_insert_input!]!

    # on conflict condition
    on_conflict: kardex_on_conflict
  ): kardex_mutation_response

  # insert a single row into the table: "kardex"
  insert_kardex_one(
    # the row to be inserted
    object: kardex_insert_input!

    # on conflict condition
    on_conflict: kardex_on_conflict
  ): kardex

  # insert data into the table: "orders"
  insert_orders(
    # the rows to be inserted
    objects: [orders_insert_input!]!

    # on conflict condition
    on_conflict: orders_on_conflict
  ): orders_mutation_response

  # insert data into the table: "orders_details"
  insert_orders_details(
    # the rows to be inserted
    objects: [orders_details_insert_input!]!

    # on conflict condition
    on_conflict: orders_details_on_conflict
  ): orders_details_mutation_response

  # insert a single row into the table: "orders_details"
  insert_orders_details_one(
    # the row to be inserted
    object: orders_details_insert_input!

    # on conflict condition
    on_conflict: orders_details_on_conflict
  ): orders_details

  # insert a single row into the table: "orders"
  insert_orders_one(
    # the row to be inserted
    object: orders_insert_input!

    # on conflict condition
    on_conflict: orders_on_conflict
  ): orders

  # insert data into the table: "price_rule"
  insert_price_rule(
    # the rows to be inserted
    objects: [price_rule_insert_input!]!

    # on conflict condition
    on_conflict: price_rule_on_conflict
  ): price_rule_mutation_response

  # insert a single row into the table: "price_rule"
  insert_price_rule_one(
    # the row to be inserted
    object: price_rule_insert_input!

    # on conflict condition
    on_conflict: price_rule_on_conflict
  ): price_rule

  # insert data into the table: "products"
  insert_products(
    # the rows to be inserted
    objects: [products_insert_input!]!

    # on conflict condition
    on_conflict: products_on_conflict
  ): products_mutation_response

  # insert data into the table: "products_categories"
  insert_products_categories(
    # the rows to be inserted
    objects: [products_categories_insert_input!]!

    # on conflict condition
    on_conflict: products_categories_on_conflict
  ): products_categories_mutation_response

  # insert a single row into the table: "products_categories"
  insert_products_categories_one(
    # the row to be inserted
    object: products_categories_insert_input!

    # on conflict condition
    on_conflict: products_categories_on_conflict
  ): products_categories

  # insert data into the table: "products_lots"
  insert_products_lots(
    # the rows to be inserted
    objects: [products_lots_insert_input!]!

    # on conflict condition
    on_conflict: products_lots_on_conflict
  ): products_lots_mutation_response

  # insert a single row into the table: "products_lots"
  insert_products_lots_one(
    # the row to be inserted
    object: products_lots_insert_input!

    # on conflict condition
    on_conflict: products_lots_on_conflict
  ): products_lots

  # insert data into the table: "products_media"
  insert_products_media(
    # the rows to be inserted
    objects: [products_media_insert_input!]!

    # on conflict condition
    on_conflict: products_media_on_conflict
  ): products_media_mutation_response

  # insert a single row into the table: "products_media"
  insert_products_media_one(
    # the row to be inserted
    object: products_media_insert_input!

    # on conflict condition
    on_conflict: products_media_on_conflict
  ): products_media

  # insert a single row into the table: "products"
  insert_products_one(
    # the row to be inserted
    object: products_insert_input!

    # on conflict condition
    on_conflict: products_on_conflict
  ): products

  # insert data into the table: "products_tags"
  insert_products_tags(
    # the rows to be inserted
    objects: [products_tags_insert_input!]!

    # on conflict condition
    on_conflict: products_tags_on_conflict
  ): products_tags_mutation_response

  # insert a single row into the table: "products_tags"
  insert_products_tags_one(
    # the row to be inserted
    object: products_tags_insert_input!

    # on conflict condition
    on_conflict: products_tags_on_conflict
  ): products_tags

  # insert data into the table: "stores"
  insert_stores(
    # the rows to be inserted
    objects: [stores_insert_input!]!

    # on conflict condition
    on_conflict: stores_on_conflict
  ): stores_mutation_response

  # insert data into the table: "stores_categories"
  insert_stores_categories(
    # the rows to be inserted
    objects: [stores_categories_insert_input!]!

    # on conflict condition
    on_conflict: stores_categories_on_conflict
  ): stores_categories_mutation_response

  # insert a single row into the table: "stores_categories"
  insert_stores_categories_one(
    # the row to be inserted
    object: stores_categories_insert_input!

    # on conflict condition
    on_conflict: stores_categories_on_conflict
  ): stores_categories

  # insert a single row into the table: "stores"
  insert_stores_one(
    # the row to be inserted
    object: stores_insert_input!

    # on conflict condition
    on_conflict: stores_on_conflict
  ): stores

  # insert data into the table: "types_movements"
  insert_types_movements(
    # the rows to be inserted
    objects: [types_movements_insert_input!]!

    # on conflict condition
    on_conflict: types_movements_on_conflict
  ): types_movements_mutation_response

  # insert a single row into the table: "types_movements"
  insert_types_movements_one(
    # the row to be inserted
    object: types_movements_insert_input!

    # on conflict condition
    on_conflict: types_movements_on_conflict
  ): types_movements

  # insert data into the table: "users"
  insert_users(
    # the rows to be inserted
    objects: [users_insert_input!]!

    # on conflict condition
    on_conflict: users_on_conflict
  ): users_mutation_response

  # insert a single row into the table: "users"
  insert_users_one(
    # the row to be inserted
    object: users_insert_input!

    # on conflict condition
    on_conflict: users_on_conflict
  ): users

  # update data of the table: "cities"
  update_cities(
    # sets the columns of the filtered rows to the given values
    _set: cities_set_input

    # filter the rows which have to be updated
    where: cities_bool_exp!
  ): cities_mutation_response

  # update single row of the table: "cities"
  update_cities_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: cities_set_input
    pk_columns: cities_pk_columns_input!
  ): cities

  # update data of the table: "countries"
  update_countries(
    # increments the integer columns with given value of the filtered values
    _inc: countries_inc_input

    # sets the columns of the filtered rows to the given values
    _set: countries_set_input

    # filter the rows which have to be updated
    where: countries_bool_exp!
  ): countries_mutation_response

  # update single row of the table: "countries"
  update_countries_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: countries_inc_input

    # sets the columns of the filtered rows to the given values
    _set: countries_set_input
    pk_columns: countries_pk_columns_input!
  ): countries

  # update data of the table: "countries_currency"
  update_countries_currency(
    # sets the columns of the filtered rows to the given values
    _set: countries_currency_set_input

    # filter the rows which have to be updated
    where: countries_currency_bool_exp!
  ): countries_currency_mutation_response

  # update single row of the table: "countries_currency"
  update_countries_currency_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: countries_currency_set_input
    pk_columns: countries_currency_pk_columns_input!
  ): countries_currency

  # update data of the table: "countries_taxes"
  update_countries_taxes(
    # increments the integer columns with given value of the filtered values
    _inc: countries_taxes_inc_input

    # sets the columns of the filtered rows to the given values
    _set: countries_taxes_set_input

    # filter the rows which have to be updated
    where: countries_taxes_bool_exp!
  ): countries_taxes_mutation_response

  # update single row of the table: "countries_taxes"
  update_countries_taxes_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: countries_taxes_inc_input

    # sets the columns of the filtered rows to the given values
    _set: countries_taxes_set_input
    pk_columns: countries_taxes_pk_columns_input!
  ): countries_taxes

  # update data of the table: "customers"
  update_customers(
    # sets the columns of the filtered rows to the given values
    _set: customers_set_input

    # filter the rows which have to be updated
    where: customers_bool_exp!
  ): customers_mutation_response

  # update data of the table: "customers_address"
  update_customers_address(
    # increments the integer columns with given value of the filtered values
    _inc: customers_address_inc_input

    # sets the columns of the filtered rows to the given values
    _set: customers_address_set_input

    # filter the rows which have to be updated
    where: customers_address_bool_exp!
  ): customers_address_mutation_response

  # update single row of the table: "customers_address"
  update_customers_address_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: customers_address_inc_input

    # sets the columns of the filtered rows to the given values
    _set: customers_address_set_input
    pk_columns: customers_address_pk_columns_input!
  ): customers_address

  # update single row of the table: "customers"
  update_customers_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: customers_set_input
    pk_columns: customers_pk_columns_input!
  ): customers

  # update data of the table: "customers_tags"
  update_customers_tags(
    # sets the columns of the filtered rows to the given values
    _set: customers_tags_set_input

    # filter the rows which have to be updated
    where: customers_tags_bool_exp!
  ): customers_tags_mutation_response

  # update single row of the table: "customers_tags"
  update_customers_tags_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: customers_tags_set_input
    pk_columns: customers_tags_pk_columns_input!
  ): customers_tags

  # update data of the table: "draft_orders"
  update_draft_orders(
    # increments the integer columns with given value of the filtered values
    _inc: draft_orders_inc_input

    # sets the columns of the filtered rows to the given values
    _set: draft_orders_set_input

    # filter the rows which have to be updated
    where: draft_orders_bool_exp!
  ): draft_orders_mutation_response

  # update single row of the table: "draft_orders"
  update_draft_orders_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: draft_orders_inc_input

    # sets the columns of the filtered rows to the given values
    _set: draft_orders_set_input
    pk_columns: draft_orders_pk_columns_input!
  ): draft_orders

  # update data of the table: "draft_orders_details"
  update_draft_orders_details(
    # increments the integer columns with given value of the filtered values
    _inc: draft_orders_details_inc_input

    # sets the columns of the filtered rows to the given values
    _set: draft_orders_details_set_input

    # filter the rows which have to be updated
    where: draft_orders_details_bool_exp!
  ): draft_orders_details_mutation_response

  # update single row of the table: "draft_orders_details"
  update_draft_orders_details_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: draft_orders_details_inc_input

    # sets the columns of the filtered rows to the given values
    _set: draft_orders_details_set_input
    pk_columns: draft_orders_details_pk_columns_input!
  ): draft_orders_details

  # update data of the table: "kardex"
  update_kardex(
    # increments the integer columns with given value of the filtered values
    _inc: kardex_inc_input

    # sets the columns of the filtered rows to the given values
    _set: kardex_set_input

    # filter the rows which have to be updated
    where: kardex_bool_exp!
  ): kardex_mutation_response

  # update single row of the table: "kardex"
  update_kardex_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: kardex_inc_input

    # sets the columns of the filtered rows to the given values
    _set: kardex_set_input
    pk_columns: kardex_pk_columns_input!
  ): kardex

  # update data of the table: "orders"
  update_orders(
    # increments the integer columns with given value of the filtered values
    _inc: orders_inc_input

    # sets the columns of the filtered rows to the given values
    _set: orders_set_input

    # filter the rows which have to be updated
    where: orders_bool_exp!
  ): orders_mutation_response

  # update single row of the table: "orders"
  update_orders_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: orders_inc_input

    # sets the columns of the filtered rows to the given values
    _set: orders_set_input
    pk_columns: orders_pk_columns_input!
  ): orders

  # update data of the table: "orders_details"
  update_orders_details(
    # increments the integer columns with given value of the filtered values
    _inc: orders_details_inc_input

    # sets the columns of the filtered rows to the given values
    _set: orders_details_set_input

    # filter the rows which have to be updated
    where: orders_details_bool_exp!
  ): orders_details_mutation_response

  # update single row of the table: "orders_details"
  update_orders_details_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: orders_details_inc_input

    # sets the columns of the filtered rows to the given values
    _set: orders_details_set_input
    pk_columns: orders_details_pk_columns_input!
  ): orders_details

  # update data of the table: "price_rule"
  update_price_rule(
    # increments the integer columns with given value of the filtered values
    _inc: price_rule_inc_input

    # sets the columns of the filtered rows to the given values
    _set: price_rule_set_input

    # filter the rows which have to be updated
    where: price_rule_bool_exp!
  ): price_rule_mutation_response

  # update single row of the table: "price_rule"
  update_price_rule_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: price_rule_inc_input

    # sets the columns of the filtered rows to the given values
    _set: price_rule_set_input
    pk_columns: price_rule_pk_columns_input!
  ): price_rule

  # update data of the table: "products"
  update_products(
    # increments the integer columns with given value of the filtered values
    _inc: products_inc_input

    # sets the columns of the filtered rows to the given values
    _set: products_set_input

    # filter the rows which have to be updated
    where: products_bool_exp!
  ): products_mutation_response

  # update single row of the table: "products"
  update_products_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: products_inc_input

    # sets the columns of the filtered rows to the given values
    _set: products_set_input
    pk_columns: products_pk_columns_input!
  ): products

  # update data of the table: "products_categories"
  update_products_categories(
    # sets the columns of the filtered rows to the given values
    _set: products_categories_set_input

    # filter the rows which have to be updated
    where: products_categories_bool_exp!
  ): products_categories_mutation_response

  # update single row of the table: "products_categories"
  update_products_categories_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: products_categories_set_input
    pk_columns: products_categories_pk_columns_input!
  ): products_categories

  # update data of the table: "products_lots"
  update_products_lots(
    # increments the integer columns with given value of the filtered values
    _inc: products_lots_inc_input

    # sets the columns of the filtered rows to the given values
    _set: products_lots_set_input

    # filter the rows which have to be updated
    where: products_lots_bool_exp!
  ): products_lots_mutation_response

  # update single row of the table: "products_lots"
  update_products_lots_by_pk(
    # increments the integer columns with given value of the filtered values
    _inc: products_lots_inc_input

    # sets the columns of the filtered rows to the given values
    _set: products_lots_set_input
    pk_columns: products_lots_pk_columns_input!
  ): products_lots

  # update data of the table: "products_media"
  update_products_media(
    # sets the columns of the filtered rows to the given values
    _set: products_media_set_input

    # filter the rows which have to be updated
    where: products_media_bool_exp!
  ): products_media_mutation_response

  # update single row of the table: "products_media"
  update_products_media_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: products_media_set_input
    pk_columns: products_media_pk_columns_input!
  ): products_media

  # update data of the table: "products_tags"
  update_products_tags(
    # sets the columns of the filtered rows to the given values
    _set: products_tags_set_input

    # filter the rows which have to be updated
    where: products_tags_bool_exp!
  ): products_tags_mutation_response

  # update single row of the table: "products_tags"
  update_products_tags_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: products_tags_set_input
    pk_columns: products_tags_pk_columns_input!
  ): products_tags

  # update data of the table: "stores"
  update_stores(
    # sets the columns of the filtered rows to the given values
    _set: stores_set_input

    # filter the rows which have to be updated
    where: stores_bool_exp!
  ): stores_mutation_response

  # update single row of the table: "stores"
  update_stores_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: stores_set_input
    pk_columns: stores_pk_columns_input!
  ): stores

  # update data of the table: "stores_categories"
  update_stores_categories(
    # sets the columns of the filtered rows to the given values
    _set: stores_categories_set_input

    # filter the rows which have to be updated
    where: stores_categories_bool_exp!
  ): stores_categories_mutation_response

  # update single row of the table: "stores_categories"
  update_stores_categories_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: stores_categories_set_input
    pk_columns: stores_categories_pk_columns_input!
  ): stores_categories

  # update data of the table: "types_movements"
  update_types_movements(
    # sets the columns of the filtered rows to the given values
    _set: types_movements_set_input

    # filter the rows which have to be updated
    where: types_movements_bool_exp!
  ): types_movements_mutation_response

  # update single row of the table: "types_movements"
  update_types_movements_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: types_movements_set_input
    pk_columns: types_movements_pk_columns_input!
  ): types_movements

  # update data of the table: "users"
  update_users(
    # sets the columns of the filtered rows to the given values
    _set: users_set_input

    # filter the rows which have to be updated
    where: users_bool_exp!
  ): users_mutation_response

  # update single row of the table: "users"
  update_users_by_pk(
    # sets the columns of the filtered rows to the given values
    _set: users_set_input
    pk_columns: users_pk_columns_input!
  ): users
}

scalar numeric

# expression to compare columns of type numeric. All fields are combined with logical 'AND'.
input numeric_comparison_exp {
  _eq: numeric
  _gt: numeric
  _gte: numeric
  _in: [numeric!]
  _is_null: Boolean
  _lt: numeric
  _lte: numeric
  _neq: numeric
  _nin: [numeric!]
}

# column ordering options
enum order_by {
  # in the ascending order, nulls last
  asc

  # in the ascending order, nulls first
  asc_nulls_first

  # in the ascending order, nulls last
  asc_nulls_last

  # in the descending order, nulls first
  desc

  # in the descending order, nulls first
  desc_nulls_first

  # in the descending order, nulls last
  desc_nulls_last
}

# columns and relationships of "orders"
type orders {
  _id: uuid!
  created_at: timestamp

  # An object relationship
  customer: customers!
  customer_id: uuid!
  discount_total: numeric
  entry_date: timestamp

  # An array relationship
  orders_details(
    # distinct select on columns
    distinct_on: [orders_details_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [orders_details_order_by!]

    # filter the rows returned
    where: orders_details_bool_exp
  ): [orders_details!]!

  # An aggregated array relationship
  orders_details_aggregate(
    # distinct select on columns
    distinct_on: [orders_details_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [orders_details_order_by!]

    # filter the rows returned
    where: orders_details_bool_exp
  ): orders_details_aggregate!

  # An object relationship
  store: stores!
  store_id: uuid!
  sub_total: numeric
  tax_total: numeric
  total: numeric
}

# aggregated selection of "orders"
type orders_aggregate {
  aggregate: orders_aggregate_fields
  nodes: [orders!]!
}

# aggregate fields of "orders"
type orders_aggregate_fields {
  avg: orders_avg_fields
  count(columns: [orders_select_column!], distinct: Boolean): Int
  max: orders_max_fields
  min: orders_min_fields
  stddev: orders_stddev_fields
  stddev_pop: orders_stddev_pop_fields
  stddev_samp: orders_stddev_samp_fields
  sum: orders_sum_fields
  var_pop: orders_var_pop_fields
  var_samp: orders_var_samp_fields
  variance: orders_variance_fields
}

# order by aggregate values of table "orders"
input orders_aggregate_order_by {
  avg: orders_avg_order_by
  count: order_by
  max: orders_max_order_by
  min: orders_min_order_by
  stddev: orders_stddev_order_by
  stddev_pop: orders_stddev_pop_order_by
  stddev_samp: orders_stddev_samp_order_by
  sum: orders_sum_order_by
  var_pop: orders_var_pop_order_by
  var_samp: orders_var_samp_order_by
  variance: orders_variance_order_by
}

# input type for inserting array relation for remote table "orders"
input orders_arr_rel_insert_input {
  data: [orders_insert_input!]!
  on_conflict: orders_on_conflict
}

# aggregate avg on columns
type orders_avg_fields {
  discount_total: Float
  sub_total: Float
  tax_total: Float
  total: Float
}

# order by avg() on columns of table "orders"
input orders_avg_order_by {
  discount_total: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# Boolean expression to filter rows from the table "orders". All fields are combined with a logical 'AND'.
input orders_bool_exp {
  _and: [orders_bool_exp]
  _id: uuid_comparison_exp
  _not: orders_bool_exp
  _or: [orders_bool_exp]
  created_at: timestamp_comparison_exp
  customer: customers_bool_exp
  customer_id: uuid_comparison_exp
  discount_total: numeric_comparison_exp
  entry_date: timestamp_comparison_exp
  orders_details: orders_details_bool_exp
  store: stores_bool_exp
  store_id: uuid_comparison_exp
  sub_total: numeric_comparison_exp
  tax_total: numeric_comparison_exp
  total: numeric_comparison_exp
}

# unique or primary key constraints on table "orders"
enum orders_constraint {
  # unique or primary key constraint
  orders_pkey
}

# columns and relationships of "orders_details"
type orders_details {
  _id: uuid!
  created_at: timestamp
  discount_total: numeric

  # An object relationship
  order: orders!
  order_id: uuid!
  price: numeric

  # An object relationship
  price_rule: price_rule!
  price_rule_id: uuid!
  product_lot_id: uuid!

  # An object relationship
  products_lot: products_lots!
  quantity: Int
  sub_total: numeric
  tax_total: numeric
  total: numeric
}

# aggregated selection of "orders_details"
type orders_details_aggregate {
  aggregate: orders_details_aggregate_fields
  nodes: [orders_details!]!
}

# aggregate fields of "orders_details"
type orders_details_aggregate_fields {
  avg: orders_details_avg_fields
  count(columns: [orders_details_select_column!], distinct: Boolean): Int
  max: orders_details_max_fields
  min: orders_details_min_fields
  stddev: orders_details_stddev_fields
  stddev_pop: orders_details_stddev_pop_fields
  stddev_samp: orders_details_stddev_samp_fields
  sum: orders_details_sum_fields
  var_pop: orders_details_var_pop_fields
  var_samp: orders_details_var_samp_fields
  variance: orders_details_variance_fields
}

# order by aggregate values of table "orders_details"
input orders_details_aggregate_order_by {
  avg: orders_details_avg_order_by
  count: order_by
  max: orders_details_max_order_by
  min: orders_details_min_order_by
  stddev: orders_details_stddev_order_by
  stddev_pop: orders_details_stddev_pop_order_by
  stddev_samp: orders_details_stddev_samp_order_by
  sum: orders_details_sum_order_by
  var_pop: orders_details_var_pop_order_by
  var_samp: orders_details_var_samp_order_by
  variance: orders_details_variance_order_by
}

# input type for inserting array relation for remote table "orders_details"
input orders_details_arr_rel_insert_input {
  data: [orders_details_insert_input!]!
  on_conflict: orders_details_on_conflict
}

# aggregate avg on columns
type orders_details_avg_fields {
  discount_total: Float
  price: Float
  quantity: Float
  sub_total: Float
  tax_total: Float
  total: Float
}

# order by avg() on columns of table "orders_details"
input orders_details_avg_order_by {
  discount_total: order_by
  price: order_by
  quantity: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# Boolean expression to filter rows from the table "orders_details". All fields are combined with a logical 'AND'.
input orders_details_bool_exp {
  _and: [orders_details_bool_exp]
  _id: uuid_comparison_exp
  _not: orders_details_bool_exp
  _or: [orders_details_bool_exp]
  created_at: timestamp_comparison_exp
  discount_total: numeric_comparison_exp
  order: orders_bool_exp
  order_id: uuid_comparison_exp
  price: numeric_comparison_exp
  price_rule: price_rule_bool_exp
  price_rule_id: uuid_comparison_exp
  product_lot_id: uuid_comparison_exp
  products_lot: products_lots_bool_exp
  quantity: Int_comparison_exp
  sub_total: numeric_comparison_exp
  tax_total: numeric_comparison_exp
  total: numeric_comparison_exp
}

# unique or primary key constraints on table "orders_details"
enum orders_details_constraint {
  # unique or primary key constraint
  orders_details_pkey
}

# input type for incrementing integer column in table "orders_details"
input orders_details_inc_input {
  discount_total: numeric
  price: numeric
  quantity: Int
  sub_total: numeric
  tax_total: numeric
  total: numeric
}

# input type for inserting data into table "orders_details"
input orders_details_insert_input {
  _id: uuid
  created_at: timestamp
  discount_total: numeric
  order: orders_obj_rel_insert_input
  order_id: uuid
  price: numeric
  price_rule: price_rule_obj_rel_insert_input
  price_rule_id: uuid
  product_lot_id: uuid
  products_lot: products_lots_obj_rel_insert_input
  quantity: Int
  sub_total: numeric
  tax_total: numeric
  total: numeric
}

# aggregate max on columns
type orders_details_max_fields {
  _id: uuid
  created_at: timestamp
  discount_total: numeric
  order_id: uuid
  price: numeric
  price_rule_id: uuid
  product_lot_id: uuid
  quantity: Int
  sub_total: numeric
  tax_total: numeric
  total: numeric
}

# order by max() on columns of table "orders_details"
input orders_details_max_order_by {
  _id: order_by
  created_at: order_by
  discount_total: order_by
  order_id: order_by
  price: order_by
  price_rule_id: order_by
  product_lot_id: order_by
  quantity: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# aggregate min on columns
type orders_details_min_fields {
  _id: uuid
  created_at: timestamp
  discount_total: numeric
  order_id: uuid
  price: numeric
  price_rule_id: uuid
  product_lot_id: uuid
  quantity: Int
  sub_total: numeric
  tax_total: numeric
  total: numeric
}

# order by min() on columns of table "orders_details"
input orders_details_min_order_by {
  _id: order_by
  created_at: order_by
  discount_total: order_by
  order_id: order_by
  price: order_by
  price_rule_id: order_by
  product_lot_id: order_by
  quantity: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# response of any mutation on the table "orders_details"
type orders_details_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [orders_details!]!
}

# input type for inserting object relation for remote table "orders_details"
input orders_details_obj_rel_insert_input {
  data: orders_details_insert_input!
  on_conflict: orders_details_on_conflict
}

# on conflict condition type for table "orders_details"
input orders_details_on_conflict {
  constraint: orders_details_constraint!
  update_columns: [orders_details_update_column!]!
  where: orders_details_bool_exp
}

# ordering options when selecting data from "orders_details"
input orders_details_order_by {
  _id: order_by
  created_at: order_by
  discount_total: order_by
  order: orders_order_by
  order_id: order_by
  price: order_by
  price_rule: price_rule_order_by
  price_rule_id: order_by
  product_lot_id: order_by
  products_lot: products_lots_order_by
  quantity: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# primary key columns input for table: "orders_details"
input orders_details_pk_columns_input {
  _id: uuid!
}

# select columns of table "orders_details"
enum orders_details_select_column {
  # column name
  _id

  # column name
  created_at

  # column name
  discount_total

  # column name
  order_id

  # column name
  price

  # column name
  price_rule_id

  # column name
  product_lot_id

  # column name
  quantity

  # column name
  sub_total

  # column name
  tax_total

  # column name
  total
}

# input type for updating data in table "orders_details"
input orders_details_set_input {
  _id: uuid
  created_at: timestamp
  discount_total: numeric
  order_id: uuid
  price: numeric
  price_rule_id: uuid
  product_lot_id: uuid
  quantity: Int
  sub_total: numeric
  tax_total: numeric
  total: numeric
}

# aggregate stddev on columns
type orders_details_stddev_fields {
  discount_total: Float
  price: Float
  quantity: Float
  sub_total: Float
  tax_total: Float
  total: Float
}

# order by stddev() on columns of table "orders_details"
input orders_details_stddev_order_by {
  discount_total: order_by
  price: order_by
  quantity: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# aggregate stddev_pop on columns
type orders_details_stddev_pop_fields {
  discount_total: Float
  price: Float
  quantity: Float
  sub_total: Float
  tax_total: Float
  total: Float
}

# order by stddev_pop() on columns of table "orders_details"
input orders_details_stddev_pop_order_by {
  discount_total: order_by
  price: order_by
  quantity: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# aggregate stddev_samp on columns
type orders_details_stddev_samp_fields {
  discount_total: Float
  price: Float
  quantity: Float
  sub_total: Float
  tax_total: Float
  total: Float
}

# order by stddev_samp() on columns of table "orders_details"
input orders_details_stddev_samp_order_by {
  discount_total: order_by
  price: order_by
  quantity: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# aggregate sum on columns
type orders_details_sum_fields {
  discount_total: numeric
  price: numeric
  quantity: Int
  sub_total: numeric
  tax_total: numeric
  total: numeric
}

# order by sum() on columns of table "orders_details"
input orders_details_sum_order_by {
  discount_total: order_by
  price: order_by
  quantity: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# update columns of table "orders_details"
enum orders_details_update_column {
  # column name
  _id

  # column name
  created_at

  # column name
  discount_total

  # column name
  order_id

  # column name
  price

  # column name
  price_rule_id

  # column name
  product_lot_id

  # column name
  quantity

  # column name
  sub_total

  # column name
  tax_total

  # column name
  total
}

# aggregate var_pop on columns
type orders_details_var_pop_fields {
  discount_total: Float
  price: Float
  quantity: Float
  sub_total: Float
  tax_total: Float
  total: Float
}

# order by var_pop() on columns of table "orders_details"
input orders_details_var_pop_order_by {
  discount_total: order_by
  price: order_by
  quantity: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# aggregate var_samp on columns
type orders_details_var_samp_fields {
  discount_total: Float
  price: Float
  quantity: Float
  sub_total: Float
  tax_total: Float
  total: Float
}

# order by var_samp() on columns of table "orders_details"
input orders_details_var_samp_order_by {
  discount_total: order_by
  price: order_by
  quantity: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# aggregate variance on columns
type orders_details_variance_fields {
  discount_total: Float
  price: Float
  quantity: Float
  sub_total: Float
  tax_total: Float
  total: Float
}

# order by variance() on columns of table "orders_details"
input orders_details_variance_order_by {
  discount_total: order_by
  price: order_by
  quantity: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# input type for incrementing integer column in table "orders"
input orders_inc_input {
  discount_total: numeric
  sub_total: numeric
  tax_total: numeric
  total: numeric
}

# input type for inserting data into table "orders"
input orders_insert_input {
  _id: uuid
  created_at: timestamp
  customer: customers_obj_rel_insert_input
  customer_id: uuid
  discount_total: numeric
  entry_date: timestamp
  orders_details: orders_details_arr_rel_insert_input
  store: stores_obj_rel_insert_input
  store_id: uuid
  sub_total: numeric
  tax_total: numeric
  total: numeric
}

# aggregate max on columns
type orders_max_fields {
  _id: uuid
  created_at: timestamp
  customer_id: uuid
  discount_total: numeric
  entry_date: timestamp
  store_id: uuid
  sub_total: numeric
  tax_total: numeric
  total: numeric
}

# order by max() on columns of table "orders"
input orders_max_order_by {
  _id: order_by
  created_at: order_by
  customer_id: order_by
  discount_total: order_by
  entry_date: order_by
  store_id: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# aggregate min on columns
type orders_min_fields {
  _id: uuid
  created_at: timestamp
  customer_id: uuid
  discount_total: numeric
  entry_date: timestamp
  store_id: uuid
  sub_total: numeric
  tax_total: numeric
  total: numeric
}

# order by min() on columns of table "orders"
input orders_min_order_by {
  _id: order_by
  created_at: order_by
  customer_id: order_by
  discount_total: order_by
  entry_date: order_by
  store_id: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# response of any mutation on the table "orders"
type orders_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [orders!]!
}

# input type for inserting object relation for remote table "orders"
input orders_obj_rel_insert_input {
  data: orders_insert_input!
  on_conflict: orders_on_conflict
}

# on conflict condition type for table "orders"
input orders_on_conflict {
  constraint: orders_constraint!
  update_columns: [orders_update_column!]!
  where: orders_bool_exp
}

# ordering options when selecting data from "orders"
input orders_order_by {
  _id: order_by
  created_at: order_by
  customer: customers_order_by
  customer_id: order_by
  discount_total: order_by
  entry_date: order_by
  orders_details_aggregate: orders_details_aggregate_order_by
  store: stores_order_by
  store_id: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# primary key columns input for table: "orders"
input orders_pk_columns_input {
  _id: uuid!
}

# select columns of table "orders"
enum orders_select_column {
  # column name
  _id

  # column name
  created_at

  # column name
  customer_id

  # column name
  discount_total

  # column name
  entry_date

  # column name
  store_id

  # column name
  sub_total

  # column name
  tax_total

  # column name
  total
}

# input type for updating data in table "orders"
input orders_set_input {
  _id: uuid
  created_at: timestamp
  customer_id: uuid
  discount_total: numeric
  entry_date: timestamp
  store_id: uuid
  sub_total: numeric
  tax_total: numeric
  total: numeric
}

# aggregate stddev on columns
type orders_stddev_fields {
  discount_total: Float
  sub_total: Float
  tax_total: Float
  total: Float
}

# order by stddev() on columns of table "orders"
input orders_stddev_order_by {
  discount_total: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# aggregate stddev_pop on columns
type orders_stddev_pop_fields {
  discount_total: Float
  sub_total: Float
  tax_total: Float
  total: Float
}

# order by stddev_pop() on columns of table "orders"
input orders_stddev_pop_order_by {
  discount_total: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# aggregate stddev_samp on columns
type orders_stddev_samp_fields {
  discount_total: Float
  sub_total: Float
  tax_total: Float
  total: Float
}

# order by stddev_samp() on columns of table "orders"
input orders_stddev_samp_order_by {
  discount_total: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# aggregate sum on columns
type orders_sum_fields {
  discount_total: numeric
  sub_total: numeric
  tax_total: numeric
  total: numeric
}

# order by sum() on columns of table "orders"
input orders_sum_order_by {
  discount_total: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# update columns of table "orders"
enum orders_update_column {
  # column name
  _id

  # column name
  created_at

  # column name
  customer_id

  # column name
  discount_total

  # column name
  entry_date

  # column name
  store_id

  # column name
  sub_total

  # column name
  tax_total

  # column name
  total
}

# aggregate var_pop on columns
type orders_var_pop_fields {
  discount_total: Float
  sub_total: Float
  tax_total: Float
  total: Float
}

# order by var_pop() on columns of table "orders"
input orders_var_pop_order_by {
  discount_total: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# aggregate var_samp on columns
type orders_var_samp_fields {
  discount_total: Float
  sub_total: Float
  tax_total: Float
  total: Float
}

# order by var_samp() on columns of table "orders"
input orders_var_samp_order_by {
  discount_total: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# aggregate variance on columns
type orders_variance_fields {
  discount_total: Float
  sub_total: Float
  tax_total: Float
  total: Float
}

# order by variance() on columns of table "orders"
input orders_variance_order_by {
  discount_total: order_by
  sub_total: order_by
  tax_total: order_by
  total: order_by
}

# columns and relationships of "price_rule"
type price_rule {
  _id: uuid!
  created_at: timestamp
  ends_at: timestamp
  once_per_costumer: bit

  # An array relationship
  orders_details(
    # distinct select on columns
    distinct_on: [orders_details_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [orders_details_order_by!]

    # filter the rows returned
    where: orders_details_bool_exp
  ): [orders_details!]!

  # An aggregated array relationship
  orders_details_aggregate(
    # distinct select on columns
    distinct_on: [orders_details_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [orders_details_order_by!]

    # filter the rows returned
    where: orders_details_bool_exp
  ): orders_details_aggregate!
  percent: bit
  price: numeric

  # An object relationship
  product: products!
  product_id: uuid!
  starts_at: timestamp
  value: numeric
}

# aggregated selection of "price_rule"
type price_rule_aggregate {
  aggregate: price_rule_aggregate_fields
  nodes: [price_rule!]!
}

# aggregate fields of "price_rule"
type price_rule_aggregate_fields {
  avg: price_rule_avg_fields
  count(columns: [price_rule_select_column!], distinct: Boolean): Int
  max: price_rule_max_fields
  min: price_rule_min_fields
  stddev: price_rule_stddev_fields
  stddev_pop: price_rule_stddev_pop_fields
  stddev_samp: price_rule_stddev_samp_fields
  sum: price_rule_sum_fields
  var_pop: price_rule_var_pop_fields
  var_samp: price_rule_var_samp_fields
  variance: price_rule_variance_fields
}

# order by aggregate values of table "price_rule"
input price_rule_aggregate_order_by {
  avg: price_rule_avg_order_by
  count: order_by
  max: price_rule_max_order_by
  min: price_rule_min_order_by
  stddev: price_rule_stddev_order_by
  stddev_pop: price_rule_stddev_pop_order_by
  stddev_samp: price_rule_stddev_samp_order_by
  sum: price_rule_sum_order_by
  var_pop: price_rule_var_pop_order_by
  var_samp: price_rule_var_samp_order_by
  variance: price_rule_variance_order_by
}

# input type for inserting array relation for remote table "price_rule"
input price_rule_arr_rel_insert_input {
  data: [price_rule_insert_input!]!
  on_conflict: price_rule_on_conflict
}

# aggregate avg on columns
type price_rule_avg_fields {
  price: Float
  value: Float
}

# order by avg() on columns of table "price_rule"
input price_rule_avg_order_by {
  price: order_by
  value: order_by
}

# Boolean expression to filter rows from the table "price_rule". All fields are combined with a logical 'AND'.
input price_rule_bool_exp {
  _and: [price_rule_bool_exp]
  _id: uuid_comparison_exp
  _not: price_rule_bool_exp
  _or: [price_rule_bool_exp]
  created_at: timestamp_comparison_exp
  ends_at: timestamp_comparison_exp
  once_per_costumer: bit_comparison_exp
  orders_details: orders_details_bool_exp
  percent: bit_comparison_exp
  price: numeric_comparison_exp
  product: products_bool_exp
  product_id: uuid_comparison_exp
  starts_at: timestamp_comparison_exp
  value: numeric_comparison_exp
}

# unique or primary key constraints on table "price_rule"
enum price_rule_constraint {
  # unique or primary key constraint
  price_rule_pkey
}

# input type for incrementing integer column in table "price_rule"
input price_rule_inc_input {
  price: numeric
  value: numeric
}

# input type for inserting data into table "price_rule"
input price_rule_insert_input {
  _id: uuid
  created_at: timestamp
  ends_at: timestamp
  once_per_costumer: bit
  orders_details: orders_details_arr_rel_insert_input
  percent: bit
  price: numeric
  product: products_obj_rel_insert_input
  product_id: uuid
  starts_at: timestamp
  value: numeric
}

# aggregate max on columns
type price_rule_max_fields {
  _id: uuid
  created_at: timestamp
  ends_at: timestamp
  price: numeric
  product_id: uuid
  starts_at: timestamp
  value: numeric
}

# order by max() on columns of table "price_rule"
input price_rule_max_order_by {
  _id: order_by
  created_at: order_by
  ends_at: order_by
  price: order_by
  product_id: order_by
  starts_at: order_by
  value: order_by
}

# aggregate min on columns
type price_rule_min_fields {
  _id: uuid
  created_at: timestamp
  ends_at: timestamp
  price: numeric
  product_id: uuid
  starts_at: timestamp
  value: numeric
}

# order by min() on columns of table "price_rule"
input price_rule_min_order_by {
  _id: order_by
  created_at: order_by
  ends_at: order_by
  price: order_by
  product_id: order_by
  starts_at: order_by
  value: order_by
}

# response of any mutation on the table "price_rule"
type price_rule_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [price_rule!]!
}

# input type for inserting object relation for remote table "price_rule"
input price_rule_obj_rel_insert_input {
  data: price_rule_insert_input!
  on_conflict: price_rule_on_conflict
}

# on conflict condition type for table "price_rule"
input price_rule_on_conflict {
  constraint: price_rule_constraint!
  update_columns: [price_rule_update_column!]!
  where: price_rule_bool_exp
}

# ordering options when selecting data from "price_rule"
input price_rule_order_by {
  _id: order_by
  created_at: order_by
  ends_at: order_by
  once_per_costumer: order_by
  orders_details_aggregate: orders_details_aggregate_order_by
  percent: order_by
  price: order_by
  product: products_order_by
  product_id: order_by
  starts_at: order_by
  value: order_by
}

# primary key columns input for table: "price_rule"
input price_rule_pk_columns_input {
  _id: uuid!
}

# select columns of table "price_rule"
enum price_rule_select_column {
  # column name
  _id

  # column name
  created_at

  # column name
  ends_at

  # column name
  once_per_costumer

  # column name
  percent

  # column name
  price

  # column name
  product_id

  # column name
  starts_at

  # column name
  value
}

# input type for updating data in table "price_rule"
input price_rule_set_input {
  _id: uuid
  created_at: timestamp
  ends_at: timestamp
  once_per_costumer: bit
  percent: bit
  price: numeric
  product_id: uuid
  starts_at: timestamp
  value: numeric
}

# aggregate stddev on columns
type price_rule_stddev_fields {
  price: Float
  value: Float
}

# order by stddev() on columns of table "price_rule"
input price_rule_stddev_order_by {
  price: order_by
  value: order_by
}

# aggregate stddev_pop on columns
type price_rule_stddev_pop_fields {
  price: Float
  value: Float
}

# order by stddev_pop() on columns of table "price_rule"
input price_rule_stddev_pop_order_by {
  price: order_by
  value: order_by
}

# aggregate stddev_samp on columns
type price_rule_stddev_samp_fields {
  price: Float
  value: Float
}

# order by stddev_samp() on columns of table "price_rule"
input price_rule_stddev_samp_order_by {
  price: order_by
  value: order_by
}

# aggregate sum on columns
type price_rule_sum_fields {
  price: numeric
  value: numeric
}

# order by sum() on columns of table "price_rule"
input price_rule_sum_order_by {
  price: order_by
  value: order_by
}

# update columns of table "price_rule"
enum price_rule_update_column {
  # column name
  _id

  # column name
  created_at

  # column name
  ends_at

  # column name
  once_per_costumer

  # column name
  percent

  # column name
  price

  # column name
  product_id

  # column name
  starts_at

  # column name
  value
}

# aggregate var_pop on columns
type price_rule_var_pop_fields {
  price: Float
  value: Float
}

# order by var_pop() on columns of table "price_rule"
input price_rule_var_pop_order_by {
  price: order_by
  value: order_by
}

# aggregate var_samp on columns
type price_rule_var_samp_fields {
  price: Float
  value: Float
}

# order by var_samp() on columns of table "price_rule"
input price_rule_var_samp_order_by {
  price: order_by
  value: order_by
}

# aggregate variance on columns
type price_rule_variance_fields {
  price: Float
  value: Float
}

# order by variance() on columns of table "price_rule"
input price_rule_variance_order_by {
  price: order_by
  value: order_by
}

# columns and relationships of "products"
type products {
  _id: uuid!
  cost: numeric

  # An object relationship
  countries_tax: countries_taxes!
  country_tax_id: uuid!
  created_at: timestamp
  description: String
  full_name: String
  price: numeric
  price_compared: numeric

  # An array relationship
  price_rules(
    # distinct select on columns
    distinct_on: [price_rule_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [price_rule_order_by!]

    # filter the rows returned
    where: price_rule_bool_exp
  ): [price_rule!]!

  # An aggregated array relationship
  price_rules_aggregate(
    # distinct select on columns
    distinct_on: [price_rule_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [price_rule_order_by!]

    # filter the rows returned
    where: price_rule_bool_exp
  ): price_rule_aggregate!
  product_category_id: uuid!

  # An object relationship
  products_category: products_categories!

  # An array relationship
  products_lots(
    # distinct select on columns
    distinct_on: [products_lots_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_lots_order_by!]

    # filter the rows returned
    where: products_lots_bool_exp
  ): [products_lots!]!

  # An aggregated array relationship
  products_lots_aggregate(
    # distinct select on columns
    distinct_on: [products_lots_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_lots_order_by!]

    # filter the rows returned
    where: products_lots_bool_exp
  ): products_lots_aggregate!

  # An array relationship
  products_media(
    # distinct select on columns
    distinct_on: [products_media_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_media_order_by!]

    # filter the rows returned
    where: products_media_bool_exp
  ): [products_media!]!

  # An aggregated array relationship
  products_media_aggregate(
    # distinct select on columns
    distinct_on: [products_media_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_media_order_by!]

    # filter the rows returned
    where: products_media_bool_exp
  ): products_media_aggregate!

  # An array relationship
  products_tags(
    # distinct select on columns
    distinct_on: [products_tags_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_tags_order_by!]

    # filter the rows returned
    where: products_tags_bool_exp
  ): [products_tags!]!

  # An aggregated array relationship
  products_tags_aggregate(
    # distinct select on columns
    distinct_on: [products_tags_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_tags_order_by!]

    # filter the rows returned
    where: products_tags_bool_exp
  ): products_tags_aggregate!

  # An object relationship
  store: stores!
  store_id: uuid!
}

# aggregated selection of "products"
type products_aggregate {
  aggregate: products_aggregate_fields
  nodes: [products!]!
}

# aggregate fields of "products"
type products_aggregate_fields {
  avg: products_avg_fields
  count(columns: [products_select_column!], distinct: Boolean): Int
  max: products_max_fields
  min: products_min_fields
  stddev: products_stddev_fields
  stddev_pop: products_stddev_pop_fields
  stddev_samp: products_stddev_samp_fields
  sum: products_sum_fields
  var_pop: products_var_pop_fields
  var_samp: products_var_samp_fields
  variance: products_variance_fields
}

# order by aggregate values of table "products"
input products_aggregate_order_by {
  avg: products_avg_order_by
  count: order_by
  max: products_max_order_by
  min: products_min_order_by
  stddev: products_stddev_order_by
  stddev_pop: products_stddev_pop_order_by
  stddev_samp: products_stddev_samp_order_by
  sum: products_sum_order_by
  var_pop: products_var_pop_order_by
  var_samp: products_var_samp_order_by
  variance: products_variance_order_by
}

# input type for inserting array relation for remote table "products"
input products_arr_rel_insert_input {
  data: [products_insert_input!]!
  on_conflict: products_on_conflict
}

# aggregate avg on columns
type products_avg_fields {
  cost: Float
  price: Float
  price_compared: Float
}

# order by avg() on columns of table "products"
input products_avg_order_by {
  cost: order_by
  price: order_by
  price_compared: order_by
}

# Boolean expression to filter rows from the table "products". All fields are combined with a logical 'AND'.
input products_bool_exp {
  _and: [products_bool_exp]
  _id: uuid_comparison_exp
  _not: products_bool_exp
  _or: [products_bool_exp]
  cost: numeric_comparison_exp
  countries_tax: countries_taxes_bool_exp
  country_tax_id: uuid_comparison_exp
  created_at: timestamp_comparison_exp
  description: String_comparison_exp
  full_name: String_comparison_exp
  price: numeric_comparison_exp
  price_compared: numeric_comparison_exp
  price_rules: price_rule_bool_exp
  product_category_id: uuid_comparison_exp
  products_category: products_categories_bool_exp
  products_lots: products_lots_bool_exp
  products_media: products_media_bool_exp
  products_tags: products_tags_bool_exp
  store: stores_bool_exp
  store_id: uuid_comparison_exp
}

# columns and relationships of "products_categories"
type products_categories {
  _id: uuid!
  created_at: timestamp
  description: String

  # An array relationship
  products(
    # distinct select on columns
    distinct_on: [products_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_order_by!]

    # filter the rows returned
    where: products_bool_exp
  ): [products!]!

  # An aggregated array relationship
  products_aggregate(
    # distinct select on columns
    distinct_on: [products_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_order_by!]

    # filter the rows returned
    where: products_bool_exp
  ): products_aggregate!
  store_id: uuid!
}

# aggregated selection of "products_categories"
type products_categories_aggregate {
  aggregate: products_categories_aggregate_fields
  nodes: [products_categories!]!
}

# aggregate fields of "products_categories"
type products_categories_aggregate_fields {
  count(columns: [products_categories_select_column!], distinct: Boolean): Int
  max: products_categories_max_fields
  min: products_categories_min_fields
}

# order by aggregate values of table "products_categories"
input products_categories_aggregate_order_by {
  count: order_by
  max: products_categories_max_order_by
  min: products_categories_min_order_by
}

# input type for inserting array relation for remote table "products_categories"
input products_categories_arr_rel_insert_input {
  data: [products_categories_insert_input!]!
  on_conflict: products_categories_on_conflict
}

# Boolean expression to filter rows from the table "products_categories". All fields are combined with a logical 'AND'.
input products_categories_bool_exp {
  _and: [products_categories_bool_exp]
  _id: uuid_comparison_exp
  _not: products_categories_bool_exp
  _or: [products_categories_bool_exp]
  created_at: timestamp_comparison_exp
  description: String_comparison_exp
  products: products_bool_exp
  store_id: uuid_comparison_exp
}

# unique or primary key constraints on table "products_categories"
enum products_categories_constraint {
  # unique or primary key constraint
  products_categories_pkey
}

# input type for inserting data into table "products_categories"
input products_categories_insert_input {
  _id: uuid
  created_at: timestamp
  description: String
  products: products_arr_rel_insert_input
  store_id: uuid
}

# aggregate max on columns
type products_categories_max_fields {
  _id: uuid
  created_at: timestamp
  description: String
  store_id: uuid
}

# order by max() on columns of table "products_categories"
input products_categories_max_order_by {
  _id: order_by
  created_at: order_by
  description: order_by
  store_id: order_by
}

# aggregate min on columns
type products_categories_min_fields {
  _id: uuid
  created_at: timestamp
  description: String
  store_id: uuid
}

# order by min() on columns of table "products_categories"
input products_categories_min_order_by {
  _id: order_by
  created_at: order_by
  description: order_by
  store_id: order_by
}

# response of any mutation on the table "products_categories"
type products_categories_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [products_categories!]!
}

# input type for inserting object relation for remote table "products_categories"
input products_categories_obj_rel_insert_input {
  data: products_categories_insert_input!
  on_conflict: products_categories_on_conflict
}

# on conflict condition type for table "products_categories"
input products_categories_on_conflict {
  constraint: products_categories_constraint!
  update_columns: [products_categories_update_column!]!
  where: products_categories_bool_exp
}

# ordering options when selecting data from "products_categories"
input products_categories_order_by {
  _id: order_by
  created_at: order_by
  description: order_by
  products_aggregate: products_aggregate_order_by
  store_id: order_by
}

# primary key columns input for table: "products_categories"
input products_categories_pk_columns_input {
  _id: uuid!
}

# select columns of table "products_categories"
enum products_categories_select_column {
  # column name
  _id

  # column name
  created_at

  # column name
  description

  # column name
  store_id
}

# input type for updating data in table "products_categories"
input products_categories_set_input {
  _id: uuid
  created_at: timestamp
  description: String
  store_id: uuid
}

# update columns of table "products_categories"
enum products_categories_update_column {
  # column name
  _id

  # column name
  created_at

  # column name
  description

  # column name
  store_id
}

# unique or primary key constraints on table "products"
enum products_constraint {
  # unique or primary key constraint
  products_pkey
}

# input type for incrementing integer column in table "products"
input products_inc_input {
  cost: numeric
  price: numeric
  price_compared: numeric
}

# input type for inserting data into table "products"
input products_insert_input {
  _id: uuid
  cost: numeric
  countries_tax: countries_taxes_obj_rel_insert_input
  country_tax_id: uuid
  created_at: timestamp
  description: String
  full_name: String
  price: numeric
  price_compared: numeric
  price_rules: price_rule_arr_rel_insert_input
  product_category_id: uuid
  products_category: products_categories_obj_rel_insert_input
  products_lots: products_lots_arr_rel_insert_input
  products_media: products_media_arr_rel_insert_input
  products_tags: products_tags_arr_rel_insert_input
  store: stores_obj_rel_insert_input
  store_id: uuid
}

# columns and relationships of "products_lots"
type products_lots {
  _id: uuid!
  created_at: timestamp

  # An array relationship
  draft_orders_details(
    # distinct select on columns
    distinct_on: [draft_orders_details_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [draft_orders_details_order_by!]

    # filter the rows returned
    where: draft_orders_details_bool_exp
  ): [draft_orders_details!]!

  # An aggregated array relationship
  draft_orders_details_aggregate(
    # distinct select on columns
    distinct_on: [draft_orders_details_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [draft_orders_details_order_by!]

    # filter the rows returned
    where: draft_orders_details_bool_exp
  ): draft_orders_details_aggregate!
  entry_date: timestamp
  entry_quantity: Int
  expires_date: timestamp

  # An array relationship
  kardexes(
    # distinct select on columns
    distinct_on: [kardex_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kardex_order_by!]

    # filter the rows returned
    where: kardex_bool_exp
  ): [kardex!]!

  # An aggregated array relationship
  kardexes_aggregate(
    # distinct select on columns
    distinct_on: [kardex_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kardex_order_by!]

    # filter the rows returned
    where: kardex_bool_exp
  ): kardex_aggregate!

  # An array relationship
  orders_details(
    # distinct select on columns
    distinct_on: [orders_details_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [orders_details_order_by!]

    # filter the rows returned
    where: orders_details_bool_exp
  ): [orders_details!]!

  # An aggregated array relationship
  orders_details_aggregate(
    # distinct select on columns
    distinct_on: [orders_details_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [orders_details_order_by!]

    # filter the rows returned
    where: orders_details_bool_exp
  ): orders_details_aggregate!

  # An object relationship
  product: products!
  product_id: uuid!
  product_media_id: uuid
  quantity: Int
  title: String
}

# aggregated selection of "products_lots"
type products_lots_aggregate {
  aggregate: products_lots_aggregate_fields
  nodes: [products_lots!]!
}

# aggregate fields of "products_lots"
type products_lots_aggregate_fields {
  avg: products_lots_avg_fields
  count(columns: [products_lots_select_column!], distinct: Boolean): Int
  max: products_lots_max_fields
  min: products_lots_min_fields
  stddev: products_lots_stddev_fields
  stddev_pop: products_lots_stddev_pop_fields
  stddev_samp: products_lots_stddev_samp_fields
  sum: products_lots_sum_fields
  var_pop: products_lots_var_pop_fields
  var_samp: products_lots_var_samp_fields
  variance: products_lots_variance_fields
}

# order by aggregate values of table "products_lots"
input products_lots_aggregate_order_by {
  avg: products_lots_avg_order_by
  count: order_by
  max: products_lots_max_order_by
  min: products_lots_min_order_by
  stddev: products_lots_stddev_order_by
  stddev_pop: products_lots_stddev_pop_order_by
  stddev_samp: products_lots_stddev_samp_order_by
  sum: products_lots_sum_order_by
  var_pop: products_lots_var_pop_order_by
  var_samp: products_lots_var_samp_order_by
  variance: products_lots_variance_order_by
}

# input type for inserting array relation for remote table "products_lots"
input products_lots_arr_rel_insert_input {
  data: [products_lots_insert_input!]!
  on_conflict: products_lots_on_conflict
}

# aggregate avg on columns
type products_lots_avg_fields {
  entry_quantity: Float
  quantity: Float
}

# order by avg() on columns of table "products_lots"
input products_lots_avg_order_by {
  entry_quantity: order_by
  quantity: order_by
}

# Boolean expression to filter rows from the table "products_lots". All fields are combined with a logical 'AND'.
input products_lots_bool_exp {
  _and: [products_lots_bool_exp]
  _id: uuid_comparison_exp
  _not: products_lots_bool_exp
  _or: [products_lots_bool_exp]
  created_at: timestamp_comparison_exp
  draft_orders_details: draft_orders_details_bool_exp
  entry_date: timestamp_comparison_exp
  entry_quantity: Int_comparison_exp
  expires_date: timestamp_comparison_exp
  kardexes: kardex_bool_exp
  orders_details: orders_details_bool_exp
  product: products_bool_exp
  product_id: uuid_comparison_exp
  product_media_id: uuid_comparison_exp
  quantity: Int_comparison_exp
  title: String_comparison_exp
}

# unique or primary key constraints on table "products_lots"
enum products_lots_constraint {
  # unique or primary key constraint
  products_lots_pkey
}

# input type for incrementing integer column in table "products_lots"
input products_lots_inc_input {
  entry_quantity: Int
  quantity: Int
}

# input type for inserting data into table "products_lots"
input products_lots_insert_input {
  _id: uuid
  created_at: timestamp
  draft_orders_details: draft_orders_details_arr_rel_insert_input
  entry_date: timestamp
  entry_quantity: Int
  expires_date: timestamp
  kardexes: kardex_arr_rel_insert_input
  orders_details: orders_details_arr_rel_insert_input
  product: products_obj_rel_insert_input
  product_id: uuid
  product_media_id: uuid
  quantity: Int
  title: String
}

# aggregate max on columns
type products_lots_max_fields {
  _id: uuid
  created_at: timestamp
  entry_date: timestamp
  entry_quantity: Int
  expires_date: timestamp
  product_id: uuid
  product_media_id: uuid
  quantity: Int
  title: String
}

# order by max() on columns of table "products_lots"
input products_lots_max_order_by {
  _id: order_by
  created_at: order_by
  entry_date: order_by
  entry_quantity: order_by
  expires_date: order_by
  product_id: order_by
  product_media_id: order_by
  quantity: order_by
  title: order_by
}

# aggregate min on columns
type products_lots_min_fields {
  _id: uuid
  created_at: timestamp
  entry_date: timestamp
  entry_quantity: Int
  expires_date: timestamp
  product_id: uuid
  product_media_id: uuid
  quantity: Int
  title: String
}

# order by min() on columns of table "products_lots"
input products_lots_min_order_by {
  _id: order_by
  created_at: order_by
  entry_date: order_by
  entry_quantity: order_by
  expires_date: order_by
  product_id: order_by
  product_media_id: order_by
  quantity: order_by
  title: order_by
}

# response of any mutation on the table "products_lots"
type products_lots_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [products_lots!]!
}

# input type for inserting object relation for remote table "products_lots"
input products_lots_obj_rel_insert_input {
  data: products_lots_insert_input!
  on_conflict: products_lots_on_conflict
}

# on conflict condition type for table "products_lots"
input products_lots_on_conflict {
  constraint: products_lots_constraint!
  update_columns: [products_lots_update_column!]!
  where: products_lots_bool_exp
}

# ordering options when selecting data from "products_lots"
input products_lots_order_by {
  _id: order_by
  created_at: order_by
  draft_orders_details_aggregate: draft_orders_details_aggregate_order_by
  entry_date: order_by
  entry_quantity: order_by
  expires_date: order_by
  kardexes_aggregate: kardex_aggregate_order_by
  orders_details_aggregate: orders_details_aggregate_order_by
  product: products_order_by
  product_id: order_by
  product_media_id: order_by
  quantity: order_by
  title: order_by
}

# primary key columns input for table: "products_lots"
input products_lots_pk_columns_input {
  _id: uuid!
}

# select columns of table "products_lots"
enum products_lots_select_column {
  # column name
  _id

  # column name
  created_at

  # column name
  entry_date

  # column name
  entry_quantity

  # column name
  expires_date

  # column name
  product_id

  # column name
  product_media_id

  # column name
  quantity

  # column name
  title
}

# input type for updating data in table "products_lots"
input products_lots_set_input {
  _id: uuid
  created_at: timestamp
  entry_date: timestamp
  entry_quantity: Int
  expires_date: timestamp
  product_id: uuid
  product_media_id: uuid
  quantity: Int
  title: String
}

# aggregate stddev on columns
type products_lots_stddev_fields {
  entry_quantity: Float
  quantity: Float
}

# order by stddev() on columns of table "products_lots"
input products_lots_stddev_order_by {
  entry_quantity: order_by
  quantity: order_by
}

# aggregate stddev_pop on columns
type products_lots_stddev_pop_fields {
  entry_quantity: Float
  quantity: Float
}

# order by stddev_pop() on columns of table "products_lots"
input products_lots_stddev_pop_order_by {
  entry_quantity: order_by
  quantity: order_by
}

# aggregate stddev_samp on columns
type products_lots_stddev_samp_fields {
  entry_quantity: Float
  quantity: Float
}

# order by stddev_samp() on columns of table "products_lots"
input products_lots_stddev_samp_order_by {
  entry_quantity: order_by
  quantity: order_by
}

# aggregate sum on columns
type products_lots_sum_fields {
  entry_quantity: Int
  quantity: Int
}

# order by sum() on columns of table "products_lots"
input products_lots_sum_order_by {
  entry_quantity: order_by
  quantity: order_by
}

# update columns of table "products_lots"
enum products_lots_update_column {
  # column name
  _id

  # column name
  created_at

  # column name
  entry_date

  # column name
  entry_quantity

  # column name
  expires_date

  # column name
  product_id

  # column name
  product_media_id

  # column name
  quantity

  # column name
  title
}

# aggregate var_pop on columns
type products_lots_var_pop_fields {
  entry_quantity: Float
  quantity: Float
}

# order by var_pop() on columns of table "products_lots"
input products_lots_var_pop_order_by {
  entry_quantity: order_by
  quantity: order_by
}

# aggregate var_samp on columns
type products_lots_var_samp_fields {
  entry_quantity: Float
  quantity: Float
}

# order by var_samp() on columns of table "products_lots"
input products_lots_var_samp_order_by {
  entry_quantity: order_by
  quantity: order_by
}

# aggregate variance on columns
type products_lots_variance_fields {
  entry_quantity: Float
  quantity: Float
}

# order by variance() on columns of table "products_lots"
input products_lots_variance_order_by {
  entry_quantity: order_by
  quantity: order_by
}

# aggregate max on columns
type products_max_fields {
  _id: uuid
  cost: numeric
  country_tax_id: uuid
  created_at: timestamp
  description: String
  full_name: String
  price: numeric
  price_compared: numeric
  product_category_id: uuid
  store_id: uuid
}

# order by max() on columns of table "products"
input products_max_order_by {
  _id: order_by
  cost: order_by
  country_tax_id: order_by
  created_at: order_by
  description: order_by
  full_name: order_by
  price: order_by
  price_compared: order_by
  product_category_id: order_by
  store_id: order_by
}

# columns and relationships of "products_media"
type products_media {
  _id: uuid!
  created_at: timestamp
  path: String
  primary_media: Boolean

  # An object relationship
  product: products!
  product_id: uuid!
}

# aggregated selection of "products_media"
type products_media_aggregate {
  aggregate: products_media_aggregate_fields
  nodes: [products_media!]!
}

# aggregate fields of "products_media"
type products_media_aggregate_fields {
  count(columns: [products_media_select_column!], distinct: Boolean): Int
  max: products_media_max_fields
  min: products_media_min_fields
}

# order by aggregate values of table "products_media"
input products_media_aggregate_order_by {
  count: order_by
  max: products_media_max_order_by
  min: products_media_min_order_by
}

# input type for inserting array relation for remote table "products_media"
input products_media_arr_rel_insert_input {
  data: [products_media_insert_input!]!
  on_conflict: products_media_on_conflict
}

# Boolean expression to filter rows from the table "products_media". All fields are combined with a logical 'AND'.
input products_media_bool_exp {
  _and: [products_media_bool_exp]
  _id: uuid_comparison_exp
  _not: products_media_bool_exp
  _or: [products_media_bool_exp]
  created_at: timestamp_comparison_exp
  path: String_comparison_exp
  primary_media: Boolean_comparison_exp
  product: products_bool_exp
  product_id: uuid_comparison_exp
}

# unique or primary key constraints on table "products_media"
enum products_media_constraint {
  # unique or primary key constraint
  products_media_pkey
}

# input type for inserting data into table "products_media"
input products_media_insert_input {
  _id: uuid
  created_at: timestamp
  path: String
  primary_media: Boolean
  product: products_obj_rel_insert_input
  product_id: uuid
}

# aggregate max on columns
type products_media_max_fields {
  _id: uuid
  created_at: timestamp
  path: String
  product_id: uuid
}

# order by max() on columns of table "products_media"
input products_media_max_order_by {
  _id: order_by
  created_at: order_by
  path: order_by
  product_id: order_by
}

# aggregate min on columns
type products_media_min_fields {
  _id: uuid
  created_at: timestamp
  path: String
  product_id: uuid
}

# order by min() on columns of table "products_media"
input products_media_min_order_by {
  _id: order_by
  created_at: order_by
  path: order_by
  product_id: order_by
}

# response of any mutation on the table "products_media"
type products_media_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [products_media!]!
}

# input type for inserting object relation for remote table "products_media"
input products_media_obj_rel_insert_input {
  data: products_media_insert_input!
  on_conflict: products_media_on_conflict
}

# on conflict condition type for table "products_media"
input products_media_on_conflict {
  constraint: products_media_constraint!
  update_columns: [products_media_update_column!]!
  where: products_media_bool_exp
}

# ordering options when selecting data from "products_media"
input products_media_order_by {
  _id: order_by
  created_at: order_by
  path: order_by
  primary_media: order_by
  product: products_order_by
  product_id: order_by
}

# primary key columns input for table: "products_media"
input products_media_pk_columns_input {
  _id: uuid!
}

# select columns of table "products_media"
enum products_media_select_column {
  # column name
  _id

  # column name
  created_at

  # column name
  path

  # column name
  primary_media

  # column name
  product_id
}

# input type for updating data in table "products_media"
input products_media_set_input {
  _id: uuid
  created_at: timestamp
  path: String
  primary_media: Boolean
  product_id: uuid
}

# update columns of table "products_media"
enum products_media_update_column {
  # column name
  _id

  # column name
  created_at

  # column name
  path

  # column name
  primary_media

  # column name
  product_id
}

# aggregate min on columns
type products_min_fields {
  _id: uuid
  cost: numeric
  country_tax_id: uuid
  created_at: timestamp
  description: String
  full_name: String
  price: numeric
  price_compared: numeric
  product_category_id: uuid
  store_id: uuid
}

# order by min() on columns of table "products"
input products_min_order_by {
  _id: order_by
  cost: order_by
  country_tax_id: order_by
  created_at: order_by
  description: order_by
  full_name: order_by
  price: order_by
  price_compared: order_by
  product_category_id: order_by
  store_id: order_by
}

# response of any mutation on the table "products"
type products_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [products!]!
}

# input type for inserting object relation for remote table "products"
input products_obj_rel_insert_input {
  data: products_insert_input!
  on_conflict: products_on_conflict
}

# on conflict condition type for table "products"
input products_on_conflict {
  constraint: products_constraint!
  update_columns: [products_update_column!]!
  where: products_bool_exp
}

# ordering options when selecting data from "products"
input products_order_by {
  _id: order_by
  cost: order_by
  countries_tax: countries_taxes_order_by
  country_tax_id: order_by
  created_at: order_by
  description: order_by
  full_name: order_by
  price: order_by
  price_compared: order_by
  price_rules_aggregate: price_rule_aggregate_order_by
  product_category_id: order_by
  products_category: products_categories_order_by
  products_lots_aggregate: products_lots_aggregate_order_by
  products_media_aggregate: products_media_aggregate_order_by
  products_tags_aggregate: products_tags_aggregate_order_by
  store: stores_order_by
  store_id: order_by
}

# primary key columns input for table: "products"
input products_pk_columns_input {
  _id: uuid!
}

# select columns of table "products"
enum products_select_column {
  # column name
  _id

  # column name
  cost

  # column name
  country_tax_id

  # column name
  created_at

  # column name
  description

  # column name
  full_name

  # column name
  price

  # column name
  price_compared

  # column name
  product_category_id

  # column name
  store_id
}

# input type for updating data in table "products"
input products_set_input {
  _id: uuid
  cost: numeric
  country_tax_id: uuid
  created_at: timestamp
  description: String
  full_name: String
  price: numeric
  price_compared: numeric
  product_category_id: uuid
  store_id: uuid
}

# aggregate stddev on columns
type products_stddev_fields {
  cost: Float
  price: Float
  price_compared: Float
}

# order by stddev() on columns of table "products"
input products_stddev_order_by {
  cost: order_by
  price: order_by
  price_compared: order_by
}

# aggregate stddev_pop on columns
type products_stddev_pop_fields {
  cost: Float
  price: Float
  price_compared: Float
}

# order by stddev_pop() on columns of table "products"
input products_stddev_pop_order_by {
  cost: order_by
  price: order_by
  price_compared: order_by
}

# aggregate stddev_samp on columns
type products_stddev_samp_fields {
  cost: Float
  price: Float
  price_compared: Float
}

# order by stddev_samp() on columns of table "products"
input products_stddev_samp_order_by {
  cost: order_by
  price: order_by
  price_compared: order_by
}

# aggregate sum on columns
type products_sum_fields {
  cost: numeric
  price: numeric
  price_compared: numeric
}

# order by sum() on columns of table "products"
input products_sum_order_by {
  cost: order_by
  price: order_by
  price_compared: order_by
}

# columns and relationships of "products_tags"
type products_tags {
  _id: uuid!
  created_at: timestamp

  # An object relationship
  product: products!
  product_id: uuid!
  tag: String
}

# aggregated selection of "products_tags"
type products_tags_aggregate {
  aggregate: products_tags_aggregate_fields
  nodes: [products_tags!]!
}

# aggregate fields of "products_tags"
type products_tags_aggregate_fields {
  count(columns: [products_tags_select_column!], distinct: Boolean): Int
  max: products_tags_max_fields
  min: products_tags_min_fields
}

# order by aggregate values of table "products_tags"
input products_tags_aggregate_order_by {
  count: order_by
  max: products_tags_max_order_by
  min: products_tags_min_order_by
}

# input type for inserting array relation for remote table "products_tags"
input products_tags_arr_rel_insert_input {
  data: [products_tags_insert_input!]!
  on_conflict: products_tags_on_conflict
}

# Boolean expression to filter rows from the table "products_tags". All fields are combined with a logical 'AND'.
input products_tags_bool_exp {
  _and: [products_tags_bool_exp]
  _id: uuid_comparison_exp
  _not: products_tags_bool_exp
  _or: [products_tags_bool_exp]
  created_at: timestamp_comparison_exp
  product: products_bool_exp
  product_id: uuid_comparison_exp
  tag: String_comparison_exp
}

# unique or primary key constraints on table "products_tags"
enum products_tags_constraint {
  # unique or primary key constraint
  products_tags_pkey
}

# input type for inserting data into table "products_tags"
input products_tags_insert_input {
  _id: uuid
  created_at: timestamp
  product: products_obj_rel_insert_input
  product_id: uuid
  tag: String
}

# aggregate max on columns
type products_tags_max_fields {
  _id: uuid
  created_at: timestamp
  product_id: uuid
  tag: String
}

# order by max() on columns of table "products_tags"
input products_tags_max_order_by {
  _id: order_by
  created_at: order_by
  product_id: order_by
  tag: order_by
}

# aggregate min on columns
type products_tags_min_fields {
  _id: uuid
  created_at: timestamp
  product_id: uuid
  tag: String
}

# order by min() on columns of table "products_tags"
input products_tags_min_order_by {
  _id: order_by
  created_at: order_by
  product_id: order_by
  tag: order_by
}

# response of any mutation on the table "products_tags"
type products_tags_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [products_tags!]!
}

# input type for inserting object relation for remote table "products_tags"
input products_tags_obj_rel_insert_input {
  data: products_tags_insert_input!
  on_conflict: products_tags_on_conflict
}

# on conflict condition type for table "products_tags"
input products_tags_on_conflict {
  constraint: products_tags_constraint!
  update_columns: [products_tags_update_column!]!
  where: products_tags_bool_exp
}

# ordering options when selecting data from "products_tags"
input products_tags_order_by {
  _id: order_by
  created_at: order_by
  product: products_order_by
  product_id: order_by
  tag: order_by
}

# primary key columns input for table: "products_tags"
input products_tags_pk_columns_input {
  _id: uuid!
}

# select columns of table "products_tags"
enum products_tags_select_column {
  # column name
  _id

  # column name
  created_at

  # column name
  product_id

  # column name
  tag
}

# input type for updating data in table "products_tags"
input products_tags_set_input {
  _id: uuid
  created_at: timestamp
  product_id: uuid
  tag: String
}

# update columns of table "products_tags"
enum products_tags_update_column {
  # column name
  _id

  # column name
  created_at

  # column name
  product_id

  # column name
  tag
}

# update columns of table "products"
enum products_update_column {
  # column name
  _id

  # column name
  cost

  # column name
  country_tax_id

  # column name
  created_at

  # column name
  description

  # column name
  full_name

  # column name
  price

  # column name
  price_compared

  # column name
  product_category_id

  # column name
  store_id
}

# aggregate var_pop on columns
type products_var_pop_fields {
  cost: Float
  price: Float
  price_compared: Float
}

# order by var_pop() on columns of table "products"
input products_var_pop_order_by {
  cost: order_by
  price: order_by
  price_compared: order_by
}

# aggregate var_samp on columns
type products_var_samp_fields {
  cost: Float
  price: Float
  price_compared: Float
}

# order by var_samp() on columns of table "products"
input products_var_samp_order_by {
  cost: order_by
  price: order_by
  price_compared: order_by
}

# aggregate variance on columns
type products_variance_fields {
  cost: Float
  price: Float
  price_compared: Float
}

# order by variance() on columns of table "products"
input products_variance_order_by {
  cost: order_by
  price: order_by
  price_compared: order_by
}

# query root
type query_root {
  # fetch data from the table: "cities"
  cities(
    # distinct select on columns
    distinct_on: [cities_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cities_order_by!]

    # filter the rows returned
    where: cities_bool_exp
  ): [cities!]!

  # fetch aggregated fields from the table: "cities"
  cities_aggregate(
    # distinct select on columns
    distinct_on: [cities_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cities_order_by!]

    # filter the rows returned
    where: cities_bool_exp
  ): cities_aggregate!

  # fetch data from the table: "cities" using primary key columns
  cities_by_pk(_id: uuid!): cities

  # fetch data from the table: "countries"
  countries(
    # distinct select on columns
    distinct_on: [countries_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [countries_order_by!]

    # filter the rows returned
    where: countries_bool_exp
  ): [countries!]!

  # fetch aggregated fields from the table: "countries"
  countries_aggregate(
    # distinct select on columns
    distinct_on: [countries_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [countries_order_by!]

    # filter the rows returned
    where: countries_bool_exp
  ): countries_aggregate!

  # fetch data from the table: "countries" using primary key columns
  countries_by_pk(_id: uuid!): countries

  # fetch data from the table: "countries_currency"
  countries_currency(
    # distinct select on columns
    distinct_on: [countries_currency_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [countries_currency_order_by!]

    # filter the rows returned
    where: countries_currency_bool_exp
  ): [countries_currency!]!

  # fetch aggregated fields from the table: "countries_currency"
  countries_currency_aggregate(
    # distinct select on columns
    distinct_on: [countries_currency_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [countries_currency_order_by!]

    # filter the rows returned
    where: countries_currency_bool_exp
  ): countries_currency_aggregate!

  # fetch data from the table: "countries_currency" using primary key columns
  countries_currency_by_pk(_id: uuid!): countries_currency

  # fetch data from the table: "countries_taxes"
  countries_taxes(
    # distinct select on columns
    distinct_on: [countries_taxes_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [countries_taxes_order_by!]

    # filter the rows returned
    where: countries_taxes_bool_exp
  ): [countries_taxes!]!

  # fetch aggregated fields from the table: "countries_taxes"
  countries_taxes_aggregate(
    # distinct select on columns
    distinct_on: [countries_taxes_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [countries_taxes_order_by!]

    # filter the rows returned
    where: countries_taxes_bool_exp
  ): countries_taxes_aggregate!

  # fetch data from the table: "countries_taxes" using primary key columns
  countries_taxes_by_pk(_id: uuid!): countries_taxes

  # fetch data from the table: "customers"
  customers(
    # distinct select on columns
    distinct_on: [customers_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customers_order_by!]

    # filter the rows returned
    where: customers_bool_exp
  ): [customers!]!

  # fetch data from the table: "customers_address"
  customers_address(
    # distinct select on columns
    distinct_on: [customers_address_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customers_address_order_by!]

    # filter the rows returned
    where: customers_address_bool_exp
  ): [customers_address!]!

  # fetch aggregated fields from the table: "customers_address"
  customers_address_aggregate(
    # distinct select on columns
    distinct_on: [customers_address_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customers_address_order_by!]

    # filter the rows returned
    where: customers_address_bool_exp
  ): customers_address_aggregate!

  # fetch data from the table: "customers_address" using primary key columns
  customers_address_by_pk(_id: uuid!): customers_address

  # fetch aggregated fields from the table: "customers"
  customers_aggregate(
    # distinct select on columns
    distinct_on: [customers_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customers_order_by!]

    # filter the rows returned
    where: customers_bool_exp
  ): customers_aggregate!

  # fetch data from the table: "customers" using primary key columns
  customers_by_pk(_id: uuid!): customers

  # fetch data from the table: "customers_tags"
  customers_tags(
    # distinct select on columns
    distinct_on: [customers_tags_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customers_tags_order_by!]

    # filter the rows returned
    where: customers_tags_bool_exp
  ): [customers_tags!]!

  # fetch aggregated fields from the table: "customers_tags"
  customers_tags_aggregate(
    # distinct select on columns
    distinct_on: [customers_tags_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customers_tags_order_by!]

    # filter the rows returned
    where: customers_tags_bool_exp
  ): customers_tags_aggregate!

  # fetch data from the table: "customers_tags" using primary key columns
  customers_tags_by_pk(_id: uuid!): customers_tags

  # fetch data from the table: "draft_orders"
  draft_orders(
    # distinct select on columns
    distinct_on: [draft_orders_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [draft_orders_order_by!]

    # filter the rows returned
    where: draft_orders_bool_exp
  ): [draft_orders!]!

  # fetch aggregated fields from the table: "draft_orders"
  draft_orders_aggregate(
    # distinct select on columns
    distinct_on: [draft_orders_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [draft_orders_order_by!]

    # filter the rows returned
    where: draft_orders_bool_exp
  ): draft_orders_aggregate!

  # fetch data from the table: "draft_orders" using primary key columns
  draft_orders_by_pk(_id: uuid!): draft_orders

  # fetch data from the table: "draft_orders_details"
  draft_orders_details(
    # distinct select on columns
    distinct_on: [draft_orders_details_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [draft_orders_details_order_by!]

    # filter the rows returned
    where: draft_orders_details_bool_exp
  ): [draft_orders_details!]!

  # fetch aggregated fields from the table: "draft_orders_details"
  draft_orders_details_aggregate(
    # distinct select on columns
    distinct_on: [draft_orders_details_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [draft_orders_details_order_by!]

    # filter the rows returned
    where: draft_orders_details_bool_exp
  ): draft_orders_details_aggregate!

  # fetch data from the table: "draft_orders_details" using primary key columns
  draft_orders_details_by_pk(_id: uuid!): draft_orders_details

  # fetch data from the table: "kardex"
  kardex(
    # distinct select on columns
    distinct_on: [kardex_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kardex_order_by!]

    # filter the rows returned
    where: kardex_bool_exp
  ): [kardex!]!

  # fetch aggregated fields from the table: "kardex"
  kardex_aggregate(
    # distinct select on columns
    distinct_on: [kardex_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kardex_order_by!]

    # filter the rows returned
    where: kardex_bool_exp
  ): kardex_aggregate!

  # fetch data from the table: "kardex" using primary key columns
  kardex_by_pk(_id: uuid!): kardex

  # fetch data from the table: "orders"
  orders(
    # distinct select on columns
    distinct_on: [orders_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [orders_order_by!]

    # filter the rows returned
    where: orders_bool_exp
  ): [orders!]!

  # fetch aggregated fields from the table: "orders"
  orders_aggregate(
    # distinct select on columns
    distinct_on: [orders_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [orders_order_by!]

    # filter the rows returned
    where: orders_bool_exp
  ): orders_aggregate!

  # fetch data from the table: "orders" using primary key columns
  orders_by_pk(_id: uuid!): orders

  # fetch data from the table: "orders_details"
  orders_details(
    # distinct select on columns
    distinct_on: [orders_details_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [orders_details_order_by!]

    # filter the rows returned
    where: orders_details_bool_exp
  ): [orders_details!]!

  # fetch aggregated fields from the table: "orders_details"
  orders_details_aggregate(
    # distinct select on columns
    distinct_on: [orders_details_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [orders_details_order_by!]

    # filter the rows returned
    where: orders_details_bool_exp
  ): orders_details_aggregate!

  # fetch data from the table: "orders_details" using primary key columns
  orders_details_by_pk(_id: uuid!): orders_details

  # fetch data from the table: "price_rule"
  price_rule(
    # distinct select on columns
    distinct_on: [price_rule_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [price_rule_order_by!]

    # filter the rows returned
    where: price_rule_bool_exp
  ): [price_rule!]!

  # fetch aggregated fields from the table: "price_rule"
  price_rule_aggregate(
    # distinct select on columns
    distinct_on: [price_rule_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [price_rule_order_by!]

    # filter the rows returned
    where: price_rule_bool_exp
  ): price_rule_aggregate!

  # fetch data from the table: "price_rule" using primary key columns
  price_rule_by_pk(_id: uuid!): price_rule

  # fetch data from the table: "products"
  products(
    # distinct select on columns
    distinct_on: [products_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_order_by!]

    # filter the rows returned
    where: products_bool_exp
  ): [products!]!

  # fetch aggregated fields from the table: "products"
  products_aggregate(
    # distinct select on columns
    distinct_on: [products_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_order_by!]

    # filter the rows returned
    where: products_bool_exp
  ): products_aggregate!

  # fetch data from the table: "products" using primary key columns
  products_by_pk(_id: uuid!): products

  # fetch data from the table: "products_categories"
  products_categories(
    # distinct select on columns
    distinct_on: [products_categories_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_categories_order_by!]

    # filter the rows returned
    where: products_categories_bool_exp
  ): [products_categories!]!

  # fetch aggregated fields from the table: "products_categories"
  products_categories_aggregate(
    # distinct select on columns
    distinct_on: [products_categories_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_categories_order_by!]

    # filter the rows returned
    where: products_categories_bool_exp
  ): products_categories_aggregate!

  # fetch data from the table: "products_categories" using primary key columns
  products_categories_by_pk(_id: uuid!): products_categories

  # fetch data from the table: "products_lots"
  products_lots(
    # distinct select on columns
    distinct_on: [products_lots_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_lots_order_by!]

    # filter the rows returned
    where: products_lots_bool_exp
  ): [products_lots!]!

  # fetch aggregated fields from the table: "products_lots"
  products_lots_aggregate(
    # distinct select on columns
    distinct_on: [products_lots_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_lots_order_by!]

    # filter the rows returned
    where: products_lots_bool_exp
  ): products_lots_aggregate!

  # fetch data from the table: "products_lots" using primary key columns
  products_lots_by_pk(_id: uuid!): products_lots

  # fetch data from the table: "products_media"
  products_media(
    # distinct select on columns
    distinct_on: [products_media_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_media_order_by!]

    # filter the rows returned
    where: products_media_bool_exp
  ): [products_media!]!

  # fetch aggregated fields from the table: "products_media"
  products_media_aggregate(
    # distinct select on columns
    distinct_on: [products_media_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_media_order_by!]

    # filter the rows returned
    where: products_media_bool_exp
  ): products_media_aggregate!

  # fetch data from the table: "products_media" using primary key columns
  products_media_by_pk(_id: uuid!): products_media

  # fetch data from the table: "products_tags"
  products_tags(
    # distinct select on columns
    distinct_on: [products_tags_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_tags_order_by!]

    # filter the rows returned
    where: products_tags_bool_exp
  ): [products_tags!]!

  # fetch aggregated fields from the table: "products_tags"
  products_tags_aggregate(
    # distinct select on columns
    distinct_on: [products_tags_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_tags_order_by!]

    # filter the rows returned
    where: products_tags_bool_exp
  ): products_tags_aggregate!

  # fetch data from the table: "products_tags" using primary key columns
  products_tags_by_pk(_id: uuid!): products_tags

  # fetch data from the table: "stores"
  stores(
    # distinct select on columns
    distinct_on: [stores_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [stores_order_by!]

    # filter the rows returned
    where: stores_bool_exp
  ): [stores!]!

  # fetch aggregated fields from the table: "stores"
  stores_aggregate(
    # distinct select on columns
    distinct_on: [stores_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [stores_order_by!]

    # filter the rows returned
    where: stores_bool_exp
  ): stores_aggregate!

  # fetch data from the table: "stores" using primary key columns
  stores_by_pk(_id: uuid!): stores

  # fetch data from the table: "stores_categories"
  stores_categories(
    # distinct select on columns
    distinct_on: [stores_categories_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [stores_categories_order_by!]

    # filter the rows returned
    where: stores_categories_bool_exp
  ): [stores_categories!]!

  # fetch aggregated fields from the table: "stores_categories"
  stores_categories_aggregate(
    # distinct select on columns
    distinct_on: [stores_categories_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [stores_categories_order_by!]

    # filter the rows returned
    where: stores_categories_bool_exp
  ): stores_categories_aggregate!

  # fetch data from the table: "stores_categories" using primary key columns
  stores_categories_by_pk(_id: uuid!): stores_categories

  # fetch data from the table: "types_movements"
  types_movements(
    # distinct select on columns
    distinct_on: [types_movements_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [types_movements_order_by!]

    # filter the rows returned
    where: types_movements_bool_exp
  ): [types_movements!]!

  # fetch aggregated fields from the table: "types_movements"
  types_movements_aggregate(
    # distinct select on columns
    distinct_on: [types_movements_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [types_movements_order_by!]

    # filter the rows returned
    where: types_movements_bool_exp
  ): types_movements_aggregate!

  # fetch data from the table: "types_movements" using primary key columns
  types_movements_by_pk(_id: uuid!): types_movements

  # fetch data from the table: "users"
  users(
    # distinct select on columns
    distinct_on: [users_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [users_order_by!]

    # filter the rows returned
    where: users_bool_exp
  ): [users!]!

  # fetch aggregated fields from the table: "users"
  users_aggregate(
    # distinct select on columns
    distinct_on: [users_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [users_order_by!]

    # filter the rows returned
    where: users_bool_exp
  ): users_aggregate!

  # fetch data from the table: "users" using primary key columns
  users_by_pk(_id: uuid!): users
}

# columns and relationships of "stores"
type stores {
  _id: uuid!
  address: String

  # An object relationship
  city: cities!
  city_id: uuid!
  contact_email: String
  created_at: timestamp

  # An array relationship
  draft_orders(
    # distinct select on columns
    distinct_on: [draft_orders_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [draft_orders_order_by!]

    # filter the rows returned
    where: draft_orders_bool_exp
  ): [draft_orders!]!

  # An aggregated array relationship
  draft_orders_aggregate(
    # distinct select on columns
    distinct_on: [draft_orders_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [draft_orders_order_by!]

    # filter the rows returned
    where: draft_orders_bool_exp
  ): draft_orders_aggregate!
  full_name: String
  logo: String

  # An array relationship
  orders(
    # distinct select on columns
    distinct_on: [orders_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [orders_order_by!]

    # filter the rows returned
    where: orders_bool_exp
  ): [orders!]!

  # An aggregated array relationship
  orders_aggregate(
    # distinct select on columns
    distinct_on: [orders_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [orders_order_by!]

    # filter the rows returned
    where: orders_bool_exp
  ): orders_aggregate!

  # An array relationship
  products(
    # distinct select on columns
    distinct_on: [products_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_order_by!]

    # filter the rows returned
    where: products_bool_exp
  ): [products!]!

  # An aggregated array relationship
  products_aggregate(
    # distinct select on columns
    distinct_on: [products_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_order_by!]

    # filter the rows returned
    where: products_bool_exp
  ): products_aggregate!
  short_name: String

  # An array relationship
  stores_categories(
    # distinct select on columns
    distinct_on: [stores_categories_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [stores_categories_order_by!]

    # filter the rows returned
    where: stores_categories_bool_exp
  ): [stores_categories!]!

  # An aggregated array relationship
  stores_categories_aggregate(
    # distinct select on columns
    distinct_on: [stores_categories_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [stores_categories_order_by!]

    # filter the rows returned
    where: stores_categories_bool_exp
  ): stores_categories_aggregate!

  # An array relationship
  users(
    # distinct select on columns
    distinct_on: [users_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [users_order_by!]

    # filter the rows returned
    where: users_bool_exp
  ): [users!]!

  # An aggregated array relationship
  users_aggregate(
    # distinct select on columns
    distinct_on: [users_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [users_order_by!]

    # filter the rows returned
    where: users_bool_exp
  ): users_aggregate!
}

# aggregated selection of "stores"
type stores_aggregate {
  aggregate: stores_aggregate_fields
  nodes: [stores!]!
}

# aggregate fields of "stores"
type stores_aggregate_fields {
  count(columns: [stores_select_column!], distinct: Boolean): Int
  max: stores_max_fields
  min: stores_min_fields
}

# order by aggregate values of table "stores"
input stores_aggregate_order_by {
  count: order_by
  max: stores_max_order_by
  min: stores_min_order_by
}

# input type for inserting array relation for remote table "stores"
input stores_arr_rel_insert_input {
  data: [stores_insert_input!]!
  on_conflict: stores_on_conflict
}

# Boolean expression to filter rows from the table "stores". All fields are combined with a logical 'AND'.
input stores_bool_exp {
  _and: [stores_bool_exp]
  _id: uuid_comparison_exp
  _not: stores_bool_exp
  _or: [stores_bool_exp]
  address: String_comparison_exp
  city: cities_bool_exp
  city_id: uuid_comparison_exp
  contact_email: String_comparison_exp
  created_at: timestamp_comparison_exp
  draft_orders: draft_orders_bool_exp
  full_name: String_comparison_exp
  logo: String_comparison_exp
  orders: orders_bool_exp
  products: products_bool_exp
  short_name: String_comparison_exp
  stores_categories: stores_categories_bool_exp
  users: users_bool_exp
}

# columns and relationships of "stores_categories"
type stores_categories {
  _id: uuid!
  created_at: timestamp
  description: String

  # An object relationship
  store: stores!
  store_id: uuid!
}

# aggregated selection of "stores_categories"
type stores_categories_aggregate {
  aggregate: stores_categories_aggregate_fields
  nodes: [stores_categories!]!
}

# aggregate fields of "stores_categories"
type stores_categories_aggregate_fields {
  count(columns: [stores_categories_select_column!], distinct: Boolean): Int
  max: stores_categories_max_fields
  min: stores_categories_min_fields
}

# order by aggregate values of table "stores_categories"
input stores_categories_aggregate_order_by {
  count: order_by
  max: stores_categories_max_order_by
  min: stores_categories_min_order_by
}

# input type for inserting array relation for remote table "stores_categories"
input stores_categories_arr_rel_insert_input {
  data: [stores_categories_insert_input!]!
  on_conflict: stores_categories_on_conflict
}

# Boolean expression to filter rows from the table "stores_categories". All fields are combined with a logical 'AND'.
input stores_categories_bool_exp {
  _and: [stores_categories_bool_exp]
  _id: uuid_comparison_exp
  _not: stores_categories_bool_exp
  _or: [stores_categories_bool_exp]
  created_at: timestamp_comparison_exp
  description: String_comparison_exp
  store: stores_bool_exp
  store_id: uuid_comparison_exp
}

# unique or primary key constraints on table "stores_categories"
enum stores_categories_constraint {
  # unique or primary key constraint
  stores_categories_pkey
}

# input type for inserting data into table "stores_categories"
input stores_categories_insert_input {
  _id: uuid
  created_at: timestamp
  description: String
  store: stores_obj_rel_insert_input
  store_id: uuid
}

# aggregate max on columns
type stores_categories_max_fields {
  _id: uuid
  created_at: timestamp
  description: String
  store_id: uuid
}

# order by max() on columns of table "stores_categories"
input stores_categories_max_order_by {
  _id: order_by
  created_at: order_by
  description: order_by
  store_id: order_by
}

# aggregate min on columns
type stores_categories_min_fields {
  _id: uuid
  created_at: timestamp
  description: String
  store_id: uuid
}

# order by min() on columns of table "stores_categories"
input stores_categories_min_order_by {
  _id: order_by
  created_at: order_by
  description: order_by
  store_id: order_by
}

# response of any mutation on the table "stores_categories"
type stores_categories_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [stores_categories!]!
}

# input type for inserting object relation for remote table "stores_categories"
input stores_categories_obj_rel_insert_input {
  data: stores_categories_insert_input!
  on_conflict: stores_categories_on_conflict
}

# on conflict condition type for table "stores_categories"
input stores_categories_on_conflict {
  constraint: stores_categories_constraint!
  update_columns: [stores_categories_update_column!]!
  where: stores_categories_bool_exp
}

# ordering options when selecting data from "stores_categories"
input stores_categories_order_by {
  _id: order_by
  created_at: order_by
  description: order_by
  store: stores_order_by
  store_id: order_by
}

# primary key columns input for table: "stores_categories"
input stores_categories_pk_columns_input {
  _id: uuid!
}

# select columns of table "stores_categories"
enum stores_categories_select_column {
  # column name
  _id

  # column name
  created_at

  # column name
  description

  # column name
  store_id
}

# input type for updating data in table "stores_categories"
input stores_categories_set_input {
  _id: uuid
  created_at: timestamp
  description: String
  store_id: uuid
}

# update columns of table "stores_categories"
enum stores_categories_update_column {
  # column name
  _id

  # column name
  created_at

  # column name
  description

  # column name
  store_id
}

# unique or primary key constraints on table "stores"
enum stores_constraint {
  # unique or primary key constraint
  stores_contact_email_key

  # unique or primary key constraint
  stores_pkey
}

# input type for inserting data into table "stores"
input stores_insert_input {
  _id: uuid
  address: String
  city: cities_obj_rel_insert_input
  city_id: uuid
  contact_email: String
  created_at: timestamp
  draft_orders: draft_orders_arr_rel_insert_input
  full_name: String
  logo: String
  orders: orders_arr_rel_insert_input
  products: products_arr_rel_insert_input
  short_name: String
  stores_categories: stores_categories_arr_rel_insert_input
  users: users_arr_rel_insert_input
}

# aggregate max on columns
type stores_max_fields {
  _id: uuid
  address: String
  city_id: uuid
  contact_email: String
  created_at: timestamp
  full_name: String
  logo: String
  short_name: String
}

# order by max() on columns of table "stores"
input stores_max_order_by {
  _id: order_by
  address: order_by
  city_id: order_by
  contact_email: order_by
  created_at: order_by
  full_name: order_by
  logo: order_by
  short_name: order_by
}

# aggregate min on columns
type stores_min_fields {
  _id: uuid
  address: String
  city_id: uuid
  contact_email: String
  created_at: timestamp
  full_name: String
  logo: String
  short_name: String
}

# order by min() on columns of table "stores"
input stores_min_order_by {
  _id: order_by
  address: order_by
  city_id: order_by
  contact_email: order_by
  created_at: order_by
  full_name: order_by
  logo: order_by
  short_name: order_by
}

# response of any mutation on the table "stores"
type stores_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [stores!]!
}

# input type for inserting object relation for remote table "stores"
input stores_obj_rel_insert_input {
  data: stores_insert_input!
  on_conflict: stores_on_conflict
}

# on conflict condition type for table "stores"
input stores_on_conflict {
  constraint: stores_constraint!
  update_columns: [stores_update_column!]!
  where: stores_bool_exp
}

# ordering options when selecting data from "stores"
input stores_order_by {
  _id: order_by
  address: order_by
  city: cities_order_by
  city_id: order_by
  contact_email: order_by
  created_at: order_by
  draft_orders_aggregate: draft_orders_aggregate_order_by
  full_name: order_by
  logo: order_by
  orders_aggregate: orders_aggregate_order_by
  products_aggregate: products_aggregate_order_by
  short_name: order_by
  stores_categories_aggregate: stores_categories_aggregate_order_by
  users_aggregate: users_aggregate_order_by
}

# primary key columns input for table: "stores"
input stores_pk_columns_input {
  _id: uuid!
}

# select columns of table "stores"
enum stores_select_column {
  # column name
  _id

  # column name
  address

  # column name
  city_id

  # column name
  contact_email

  # column name
  created_at

  # column name
  full_name

  # column name
  logo

  # column name
  short_name
}

# input type for updating data in table "stores"
input stores_set_input {
  _id: uuid
  address: String
  city_id: uuid
  contact_email: String
  created_at: timestamp
  full_name: String
  logo: String
  short_name: String
}

# update columns of table "stores"
enum stores_update_column {
  # column name
  _id

  # column name
  address

  # column name
  city_id

  # column name
  contact_email

  # column name
  created_at

  # column name
  full_name

  # column name
  logo

  # column name
  short_name
}

# expression to compare columns of type String. All fields are combined with logical 'AND'.
input String_comparison_exp {
  _eq: String
  _gt: String
  _gte: String
  _ilike: String
  _in: [String!]
  _is_null: Boolean
  _like: String
  _lt: String
  _lte: String
  _neq: String
  _nilike: String
  _nin: [String!]
  _nlike: String
  _nsimilar: String
  _similar: String
}

# subscription root
type subscription_root {
  # fetch data from the table: "cities"
  cities(
    # distinct select on columns
    distinct_on: [cities_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cities_order_by!]

    # filter the rows returned
    where: cities_bool_exp
  ): [cities!]!

  # fetch aggregated fields from the table: "cities"
  cities_aggregate(
    # distinct select on columns
    distinct_on: [cities_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [cities_order_by!]

    # filter the rows returned
    where: cities_bool_exp
  ): cities_aggregate!

  # fetch data from the table: "cities" using primary key columns
  cities_by_pk(_id: uuid!): cities

  # fetch data from the table: "countries"
  countries(
    # distinct select on columns
    distinct_on: [countries_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [countries_order_by!]

    # filter the rows returned
    where: countries_bool_exp
  ): [countries!]!

  # fetch aggregated fields from the table: "countries"
  countries_aggregate(
    # distinct select on columns
    distinct_on: [countries_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [countries_order_by!]

    # filter the rows returned
    where: countries_bool_exp
  ): countries_aggregate!

  # fetch data from the table: "countries" using primary key columns
  countries_by_pk(_id: uuid!): countries

  # fetch data from the table: "countries_currency"
  countries_currency(
    # distinct select on columns
    distinct_on: [countries_currency_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [countries_currency_order_by!]

    # filter the rows returned
    where: countries_currency_bool_exp
  ): [countries_currency!]!

  # fetch aggregated fields from the table: "countries_currency"
  countries_currency_aggregate(
    # distinct select on columns
    distinct_on: [countries_currency_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [countries_currency_order_by!]

    # filter the rows returned
    where: countries_currency_bool_exp
  ): countries_currency_aggregate!

  # fetch data from the table: "countries_currency" using primary key columns
  countries_currency_by_pk(_id: uuid!): countries_currency

  # fetch data from the table: "countries_taxes"
  countries_taxes(
    # distinct select on columns
    distinct_on: [countries_taxes_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [countries_taxes_order_by!]

    # filter the rows returned
    where: countries_taxes_bool_exp
  ): [countries_taxes!]!

  # fetch aggregated fields from the table: "countries_taxes"
  countries_taxes_aggregate(
    # distinct select on columns
    distinct_on: [countries_taxes_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [countries_taxes_order_by!]

    # filter the rows returned
    where: countries_taxes_bool_exp
  ): countries_taxes_aggregate!

  # fetch data from the table: "countries_taxes" using primary key columns
  countries_taxes_by_pk(_id: uuid!): countries_taxes

  # fetch data from the table: "customers"
  customers(
    # distinct select on columns
    distinct_on: [customers_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customers_order_by!]

    # filter the rows returned
    where: customers_bool_exp
  ): [customers!]!

  # fetch data from the table: "customers_address"
  customers_address(
    # distinct select on columns
    distinct_on: [customers_address_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customers_address_order_by!]

    # filter the rows returned
    where: customers_address_bool_exp
  ): [customers_address!]!

  # fetch aggregated fields from the table: "customers_address"
  customers_address_aggregate(
    # distinct select on columns
    distinct_on: [customers_address_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customers_address_order_by!]

    # filter the rows returned
    where: customers_address_bool_exp
  ): customers_address_aggregate!

  # fetch data from the table: "customers_address" using primary key columns
  customers_address_by_pk(_id: uuid!): customers_address

  # fetch aggregated fields from the table: "customers"
  customers_aggregate(
    # distinct select on columns
    distinct_on: [customers_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customers_order_by!]

    # filter the rows returned
    where: customers_bool_exp
  ): customers_aggregate!

  # fetch data from the table: "customers" using primary key columns
  customers_by_pk(_id: uuid!): customers

  # fetch data from the table: "customers_tags"
  customers_tags(
    # distinct select on columns
    distinct_on: [customers_tags_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customers_tags_order_by!]

    # filter the rows returned
    where: customers_tags_bool_exp
  ): [customers_tags!]!

  # fetch aggregated fields from the table: "customers_tags"
  customers_tags_aggregate(
    # distinct select on columns
    distinct_on: [customers_tags_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [customers_tags_order_by!]

    # filter the rows returned
    where: customers_tags_bool_exp
  ): customers_tags_aggregate!

  # fetch data from the table: "customers_tags" using primary key columns
  customers_tags_by_pk(_id: uuid!): customers_tags

  # fetch data from the table: "draft_orders"
  draft_orders(
    # distinct select on columns
    distinct_on: [draft_orders_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [draft_orders_order_by!]

    # filter the rows returned
    where: draft_orders_bool_exp
  ): [draft_orders!]!

  # fetch aggregated fields from the table: "draft_orders"
  draft_orders_aggregate(
    # distinct select on columns
    distinct_on: [draft_orders_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [draft_orders_order_by!]

    # filter the rows returned
    where: draft_orders_bool_exp
  ): draft_orders_aggregate!

  # fetch data from the table: "draft_orders" using primary key columns
  draft_orders_by_pk(_id: uuid!): draft_orders

  # fetch data from the table: "draft_orders_details"
  draft_orders_details(
    # distinct select on columns
    distinct_on: [draft_orders_details_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [draft_orders_details_order_by!]

    # filter the rows returned
    where: draft_orders_details_bool_exp
  ): [draft_orders_details!]!

  # fetch aggregated fields from the table: "draft_orders_details"
  draft_orders_details_aggregate(
    # distinct select on columns
    distinct_on: [draft_orders_details_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [draft_orders_details_order_by!]

    # filter the rows returned
    where: draft_orders_details_bool_exp
  ): draft_orders_details_aggregate!

  # fetch data from the table: "draft_orders_details" using primary key columns
  draft_orders_details_by_pk(_id: uuid!): draft_orders_details

  # fetch data from the table: "kardex"
  kardex(
    # distinct select on columns
    distinct_on: [kardex_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kardex_order_by!]

    # filter the rows returned
    where: kardex_bool_exp
  ): [kardex!]!

  # fetch aggregated fields from the table: "kardex"
  kardex_aggregate(
    # distinct select on columns
    distinct_on: [kardex_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kardex_order_by!]

    # filter the rows returned
    where: kardex_bool_exp
  ): kardex_aggregate!

  # fetch data from the table: "kardex" using primary key columns
  kardex_by_pk(_id: uuid!): kardex

  # fetch data from the table: "orders"
  orders(
    # distinct select on columns
    distinct_on: [orders_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [orders_order_by!]

    # filter the rows returned
    where: orders_bool_exp
  ): [orders!]!

  # fetch aggregated fields from the table: "orders"
  orders_aggregate(
    # distinct select on columns
    distinct_on: [orders_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [orders_order_by!]

    # filter the rows returned
    where: orders_bool_exp
  ): orders_aggregate!

  # fetch data from the table: "orders" using primary key columns
  orders_by_pk(_id: uuid!): orders

  # fetch data from the table: "orders_details"
  orders_details(
    # distinct select on columns
    distinct_on: [orders_details_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [orders_details_order_by!]

    # filter the rows returned
    where: orders_details_bool_exp
  ): [orders_details!]!

  # fetch aggregated fields from the table: "orders_details"
  orders_details_aggregate(
    # distinct select on columns
    distinct_on: [orders_details_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [orders_details_order_by!]

    # filter the rows returned
    where: orders_details_bool_exp
  ): orders_details_aggregate!

  # fetch data from the table: "orders_details" using primary key columns
  orders_details_by_pk(_id: uuid!): orders_details

  # fetch data from the table: "price_rule"
  price_rule(
    # distinct select on columns
    distinct_on: [price_rule_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [price_rule_order_by!]

    # filter the rows returned
    where: price_rule_bool_exp
  ): [price_rule!]!

  # fetch aggregated fields from the table: "price_rule"
  price_rule_aggregate(
    # distinct select on columns
    distinct_on: [price_rule_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [price_rule_order_by!]

    # filter the rows returned
    where: price_rule_bool_exp
  ): price_rule_aggregate!

  # fetch data from the table: "price_rule" using primary key columns
  price_rule_by_pk(_id: uuid!): price_rule

  # fetch data from the table: "products"
  products(
    # distinct select on columns
    distinct_on: [products_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_order_by!]

    # filter the rows returned
    where: products_bool_exp
  ): [products!]!

  # fetch aggregated fields from the table: "products"
  products_aggregate(
    # distinct select on columns
    distinct_on: [products_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_order_by!]

    # filter the rows returned
    where: products_bool_exp
  ): products_aggregate!

  # fetch data from the table: "products" using primary key columns
  products_by_pk(_id: uuid!): products

  # fetch data from the table: "products_categories"
  products_categories(
    # distinct select on columns
    distinct_on: [products_categories_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_categories_order_by!]

    # filter the rows returned
    where: products_categories_bool_exp
  ): [products_categories!]!

  # fetch aggregated fields from the table: "products_categories"
  products_categories_aggregate(
    # distinct select on columns
    distinct_on: [products_categories_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_categories_order_by!]

    # filter the rows returned
    where: products_categories_bool_exp
  ): products_categories_aggregate!

  # fetch data from the table: "products_categories" using primary key columns
  products_categories_by_pk(_id: uuid!): products_categories

  # fetch data from the table: "products_lots"
  products_lots(
    # distinct select on columns
    distinct_on: [products_lots_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_lots_order_by!]

    # filter the rows returned
    where: products_lots_bool_exp
  ): [products_lots!]!

  # fetch aggregated fields from the table: "products_lots"
  products_lots_aggregate(
    # distinct select on columns
    distinct_on: [products_lots_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_lots_order_by!]

    # filter the rows returned
    where: products_lots_bool_exp
  ): products_lots_aggregate!

  # fetch data from the table: "products_lots" using primary key columns
  products_lots_by_pk(_id: uuid!): products_lots

  # fetch data from the table: "products_media"
  products_media(
    # distinct select on columns
    distinct_on: [products_media_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_media_order_by!]

    # filter the rows returned
    where: products_media_bool_exp
  ): [products_media!]!

  # fetch aggregated fields from the table: "products_media"
  products_media_aggregate(
    # distinct select on columns
    distinct_on: [products_media_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_media_order_by!]

    # filter the rows returned
    where: products_media_bool_exp
  ): products_media_aggregate!

  # fetch data from the table: "products_media" using primary key columns
  products_media_by_pk(_id: uuid!): products_media

  # fetch data from the table: "products_tags"
  products_tags(
    # distinct select on columns
    distinct_on: [products_tags_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_tags_order_by!]

    # filter the rows returned
    where: products_tags_bool_exp
  ): [products_tags!]!

  # fetch aggregated fields from the table: "products_tags"
  products_tags_aggregate(
    # distinct select on columns
    distinct_on: [products_tags_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [products_tags_order_by!]

    # filter the rows returned
    where: products_tags_bool_exp
  ): products_tags_aggregate!

  # fetch data from the table: "products_tags" using primary key columns
  products_tags_by_pk(_id: uuid!): products_tags

  # fetch data from the table: "stores"
  stores(
    # distinct select on columns
    distinct_on: [stores_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [stores_order_by!]

    # filter the rows returned
    where: stores_bool_exp
  ): [stores!]!

  # fetch aggregated fields from the table: "stores"
  stores_aggregate(
    # distinct select on columns
    distinct_on: [stores_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [stores_order_by!]

    # filter the rows returned
    where: stores_bool_exp
  ): stores_aggregate!

  # fetch data from the table: "stores" using primary key columns
  stores_by_pk(_id: uuid!): stores

  # fetch data from the table: "stores_categories"
  stores_categories(
    # distinct select on columns
    distinct_on: [stores_categories_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [stores_categories_order_by!]

    # filter the rows returned
    where: stores_categories_bool_exp
  ): [stores_categories!]!

  # fetch aggregated fields from the table: "stores_categories"
  stores_categories_aggregate(
    # distinct select on columns
    distinct_on: [stores_categories_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [stores_categories_order_by!]

    # filter the rows returned
    where: stores_categories_bool_exp
  ): stores_categories_aggregate!

  # fetch data from the table: "stores_categories" using primary key columns
  stores_categories_by_pk(_id: uuid!): stores_categories

  # fetch data from the table: "types_movements"
  types_movements(
    # distinct select on columns
    distinct_on: [types_movements_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [types_movements_order_by!]

    # filter the rows returned
    where: types_movements_bool_exp
  ): [types_movements!]!

  # fetch aggregated fields from the table: "types_movements"
  types_movements_aggregate(
    # distinct select on columns
    distinct_on: [types_movements_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [types_movements_order_by!]

    # filter the rows returned
    where: types_movements_bool_exp
  ): types_movements_aggregate!

  # fetch data from the table: "types_movements" using primary key columns
  types_movements_by_pk(_id: uuid!): types_movements

  # fetch data from the table: "users"
  users(
    # distinct select on columns
    distinct_on: [users_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [users_order_by!]

    # filter the rows returned
    where: users_bool_exp
  ): [users!]!

  # fetch aggregated fields from the table: "users"
  users_aggregate(
    # distinct select on columns
    distinct_on: [users_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [users_order_by!]

    # filter the rows returned
    where: users_bool_exp
  ): users_aggregate!

  # fetch data from the table: "users" using primary key columns
  users_by_pk(_id: uuid!): users
}

scalar timestamp

# expression to compare columns of type timestamp. All fields are combined with logical 'AND'.
input timestamp_comparison_exp {
  _eq: timestamp
  _gt: timestamp
  _gte: timestamp
  _in: [timestamp!]
  _is_null: Boolean
  _lt: timestamp
  _lte: timestamp
  _neq: timestamp
  _nin: [timestamp!]
}

# columns and relationships of "types_movements"
type types_movements {
  _id: uuid!
  created_at: timestamp
  credit: bit
  debit: bit
  description: String

  # An array relationship
  kardexes(
    # distinct select on columns
    distinct_on: [kardex_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kardex_order_by!]

    # filter the rows returned
    where: kardex_bool_exp
  ): [kardex!]!

  # An aggregated array relationship
  kardexes_aggregate(
    # distinct select on columns
    distinct_on: [kardex_select_column!]

    # limit the number of rows returned
    limit: Int

    # skip the first n rows. Use only with order_by
    offset: Int

    # sort the rows by one or more columns
    order_by: [kardex_order_by!]

    # filter the rows returned
    where: kardex_bool_exp
  ): kardex_aggregate!
}

# aggregated selection of "types_movements"
type types_movements_aggregate {
  aggregate: types_movements_aggregate_fields
  nodes: [types_movements!]!
}

# aggregate fields of "types_movements"
type types_movements_aggregate_fields {
  count(columns: [types_movements_select_column!], distinct: Boolean): Int
  max: types_movements_max_fields
  min: types_movements_min_fields
}

# order by aggregate values of table "types_movements"
input types_movements_aggregate_order_by {
  count: order_by
  max: types_movements_max_order_by
  min: types_movements_min_order_by
}

# input type for inserting array relation for remote table "types_movements"
input types_movements_arr_rel_insert_input {
  data: [types_movements_insert_input!]!
  on_conflict: types_movements_on_conflict
}

# Boolean expression to filter rows from the table "types_movements". All fields are combined with a logical 'AND'.
input types_movements_bool_exp {
  _and: [types_movements_bool_exp]
  _id: uuid_comparison_exp
  _not: types_movements_bool_exp
  _or: [types_movements_bool_exp]
  created_at: timestamp_comparison_exp
  credit: bit_comparison_exp
  debit: bit_comparison_exp
  description: String_comparison_exp
  kardexes: kardex_bool_exp
}

# unique or primary key constraints on table "types_movements"
enum types_movements_constraint {
  # unique or primary key constraint
  types_movements_pkey
}

# input type for inserting data into table "types_movements"
input types_movements_insert_input {
  _id: uuid
  created_at: timestamp
  credit: bit
  debit: bit
  description: String
  kardexes: kardex_arr_rel_insert_input
}

# aggregate max on columns
type types_movements_max_fields {
  _id: uuid
  created_at: timestamp
  description: String
}

# order by max() on columns of table "types_movements"
input types_movements_max_order_by {
  _id: order_by
  created_at: order_by
  description: order_by
}

# aggregate min on columns
type types_movements_min_fields {
  _id: uuid
  created_at: timestamp
  description: String
}

# order by min() on columns of table "types_movements"
input types_movements_min_order_by {
  _id: order_by
  created_at: order_by
  description: order_by
}

# response of any mutation on the table "types_movements"
type types_movements_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [types_movements!]!
}

# input type for inserting object relation for remote table "types_movements"
input types_movements_obj_rel_insert_input {
  data: types_movements_insert_input!
  on_conflict: types_movements_on_conflict
}

# on conflict condition type for table "types_movements"
input types_movements_on_conflict {
  constraint: types_movements_constraint!
  update_columns: [types_movements_update_column!]!
  where: types_movements_bool_exp
}

# ordering options when selecting data from "types_movements"
input types_movements_order_by {
  _id: order_by
  created_at: order_by
  credit: order_by
  debit: order_by
  description: order_by
  kardexes_aggregate: kardex_aggregate_order_by
}

# primary key columns input for table: "types_movements"
input types_movements_pk_columns_input {
  _id: uuid!
}

# select columns of table "types_movements"
enum types_movements_select_column {
  # column name
  _id

  # column name
  created_at

  # column name
  credit

  # column name
  debit

  # column name
  description
}

# input type for updating data in table "types_movements"
input types_movements_set_input {
  _id: uuid
  created_at: timestamp
  credit: bit
  debit: bit
  description: String
}

# update columns of table "types_movements"
enum types_movements_update_column {
  # column name
  _id

  # column name
  created_at

  # column name
  credit

  # column name
  debit

  # column name
  description
}

# columns and relationships of "users"
type users {
  _id: uuid!
  created_at: timestamp
  email: String
  first_name: String
  last_name: String
  password: String

  # An object relationship
  store: stores!
  store_id: uuid!
}

# aggregated selection of "users"
type users_aggregate {
  aggregate: users_aggregate_fields
  nodes: [users!]!
}

# aggregate fields of "users"
type users_aggregate_fields {
  count(columns: [users_select_column!], distinct: Boolean): Int
  max: users_max_fields
  min: users_min_fields
}

# order by aggregate values of table "users"
input users_aggregate_order_by {
  count: order_by
  max: users_max_order_by
  min: users_min_order_by
}

# input type for inserting array relation for remote table "users"
input users_arr_rel_insert_input {
  data: [users_insert_input!]!
  on_conflict: users_on_conflict
}

# Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'.
input users_bool_exp {
  _and: [users_bool_exp]
  _id: uuid_comparison_exp
  _not: users_bool_exp
  _or: [users_bool_exp]
  created_at: timestamp_comparison_exp
  email: String_comparison_exp
  first_name: String_comparison_exp
  last_name: String_comparison_exp
  password: String_comparison_exp
  store: stores_bool_exp
  store_id: uuid_comparison_exp
}

# unique or primary key constraints on table "users"
enum users_constraint {
  # unique or primary key constraint
  users_pkey
}

# input type for inserting data into table "users"
input users_insert_input {
  _id: uuid
  created_at: timestamp
  email: String
  first_name: String
  last_name: String
  password: String
  store: stores_obj_rel_insert_input
  store_id: uuid
}

# aggregate max on columns
type users_max_fields {
  _id: uuid
  created_at: timestamp
  email: String
  first_name: String
  last_name: String
  password: String
  store_id: uuid
}

# order by max() on columns of table "users"
input users_max_order_by {
  _id: order_by
  created_at: order_by
  email: order_by
  first_name: order_by
  last_name: order_by
  password: order_by
  store_id: order_by
}

# aggregate min on columns
type users_min_fields {
  _id: uuid
  created_at: timestamp
  email: String
  first_name: String
  last_name: String
  password: String
  store_id: uuid
}

# order by min() on columns of table "users"
input users_min_order_by {
  _id: order_by
  created_at: order_by
  email: order_by
  first_name: order_by
  last_name: order_by
  password: order_by
  store_id: order_by
}

# response of any mutation on the table "users"
type users_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!

  # data of the affected rows by the mutation
  returning: [users!]!
}

# input type for inserting object relation for remote table "users"
input users_obj_rel_insert_input {
  data: users_insert_input!
  on_conflict: users_on_conflict
}

# on conflict condition type for table "users"
input users_on_conflict {
  constraint: users_constraint!
  update_columns: [users_update_column!]!
  where: users_bool_exp
}

# ordering options when selecting data from "users"
input users_order_by {
  _id: order_by
  created_at: order_by
  email: order_by
  first_name: order_by
  last_name: order_by
  password: order_by
  store: stores_order_by
  store_id: order_by
}

# primary key columns input for table: "users"
input users_pk_columns_input {
  _id: uuid!
}

# select columns of table "users"
enum users_select_column {
  # column name
  _id

  # column name
  created_at

  # column name
  email

  # column name
  first_name

  # column name
  last_name

  # column name
  password

  # column name
  store_id
}

# input type for updating data in table "users"
input users_set_input {
  _id: uuid
  created_at: timestamp
  email: String
  first_name: String
  last_name: String
  password: String
  store_id: uuid
}

# update columns of table "users"
enum users_update_column {
  # column name
  _id

  # column name
  created_at

  # column name
  email

  # column name
  first_name

  # column name
  last_name

  # column name
  password

  # column name
  store_id
}

scalar uuid

# expression to compare columns of type uuid. All fields are combined with logical 'AND'.
input uuid_comparison_exp {
  _eq: uuid
  _gt: uuid
  _gte: uuid
  _in: [uuid!]
  _is_null: Boolean
  _lt: uuid
  _lte: uuid
  _neq: uuid
  _nin: [uuid!]
}

